/*** DTB_USER_CODE_START vvv Add file header below vvv ***/
//%%  (c) Copyright 1993, 1994 Hewlett-Packard Company
//%%  (c) Copyright 1993, 1994 International Business Machines Corp.
//%%  (c) Copyright 1993, 1994 Sun Microsystems, Inc.
//%%  (c) Copyright 1993, 1994 Novell, Inc.
//%%  $XConsortium: fileChooser_stubs.C.src /main/4 1996/10/14 09:35:42 barstow $
/*** DTB_USER_CODE_END   ^^^ Add file header above ^^^ ***/

/*
 * File: fileChooser_stubs.c
 * Contains: Module callbacks and connection functions
 *
 * This file was generated by dtcodegen, from module fileChooser
 *
 * Any text may be added between the DTB_USER_CODE_START and
 * DTB_USER_CODE_END comments (even non-C code). Descriptive comments
 * are provided only as an aid.
 *
 *  ** EDIT ONLY WITHIN SECTIONS MARKED WITH DTB_USER_CODE COMMENTS.  **
 *  ** ALL OTHER MODIFICATIONS WILL BE OVERWRITTEN. DO NOT MODIFY OR  **
 *  ** DELETE THE GENERATED COMMENTS!                                 **
 */

#include <stdio.h>
#include <Xm/Xm.h>
#include "dtb_utils.h"
#include "fileChooser_ui.h"


/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All necessary header files have been included.
 ***
 *** Add include files, types, macros, externs, and user functions here.
 ***/

#include <unistd.h>
#include <sys/wait.h>
#include <Xm/TextF.h>

#if defined(linux) || defined(CSRG_BASED)
#include <fstream>
#include <strstream>
#else
#include <fstream.h>
#include <strstream.h>
#endif

#include "DtTt.h"
#include "ttsnoop_ui.h"

/*
 * There is no public header file for this function (only an
 * internal header XmStringI.h).
 */
extern "C" {
extern XtPointer _XmStringUngenerate (XmString string,
                        XmStringTag tag,
                        XmTextType tag_type,
                        XmTextType output_type);
}

extern std::ofstream snoopStream;
extern int	globalTimeout;

typedef struct _FileChooserInfo {
	_DtFileChooserAction	choice;
	void *			entity;
} FileChooserInfo;

void
_DtFileChooserSet(
	_DtFileChooserAction	choice,
	void *			entity
)
{
	char *okString;
	char *title;
	char *valueLabel;
	switch (choice) {
	    case _DtFileChoosePatternAdd:
		okString = "Add";
		title = "tt_pattern_file_add";
		break;
	    case _DtFileChooseMessageSet:
		okString = "Set";
		title = "tt_message_file_set";
		break;
	    case _DtFileChooseJoin:
		okString = "Join";
		title = "tt_file_join";
		break;
	    case _DtFileChooseDtJoin:
		okString = "Join";
		title = "ttdt_file_join";
		break;
	    case _DtFileChooseQuit:
		okString = "Quit";
		title = "tt_file_quit";
		break;
	    case _DtFileChooseDefault:
		okString = "Set";
		title = "tt_default_file_set";
		break;
	    case _DtFileChooseGetModified:
		okString = "Get";
		title = "ttdt_Get_Modified";
		break;
	    case _DtFileChooseSave:
		okString = "Save";
		title = "ttdt_Save";
		break;
	    case _DtFileChooseRevert:
		okString = "Revert";
		title = "ttdt_Revert";
		break;
	    case _DtFileChooseNetfile:
		okString = "Netfile";
		title = "tt_file_netfile";
		break;
	    case _DtFileChooseChdir:
		okString = "chdir";
		title = "chdir(2)";
		break;
	    case _DtFileChooseTypesLoad:
		okString = "Load";
		title = "tt_session_types_load";
		break;
	    default:
		return;
	}
	DtbFileChooserFchooserInfo instance =
		&dtb_file_chooser_fchooser;
	if (! instance->initialized) {
		dtb_file_chooser_fchooser_initialize(
			instance, dtb_ttsnoop_ttsnoop_win.ttsnoopWin );
	}
	XmString okXmString = XmStringCreateLocalized( okString );
	XtVaSetValues( instance->fchooser, XmNokLabelString, okXmString, 0 );
	XmStringFree( okXmString );
	XtVaSetValues( instance->fchooser_shell, XmNtitle, title, 0 );

	// Remember dialog mode, entity
	FileChooserInfo *info = new FileChooserInfo;
	info->choice = choice;
	info->entity = entity;
	XtVaSetValues( instance->fchooser, XmNuserData, info, 0 );

	XtManageChild( instance->fchooser );
}

static Tt_message
snoopFileMsg(
	Tt_message      msg,
	Tttk_op		op,
	char *		pathname,
	void *		clientData,
	int		trust,
	int		isMe
)
{
	tt_free( pathname );
	DtTtCreated( DTTT_MESSAGE, msg );
	snoopIt( "Ttdt_file_cb", (void *) snoopFileMsg, msg );
	if (   (tt_message_class( msg ) == TT_REQUEST)
	    && (tt_message_state( msg ) == TT_SENT))
	{
		// Let user fill in the answer
		Widget newWidget = DtTtMessageWidgetCreate(
				    dtb_ttsnoop_ttsnoop_win.ttsnoopWin,
				    msg, DtTtMessageWidgetUpdate );
		if (! tt_is_err( tt_ptr_error( newWidget ) )) {
			XRaiseWindow( XtDisplay( newWidget ),
				      XtWindow( newWidget ));
		}
	}
	return 0;
}

/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/



void 
fileOkayed(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    DtbFileChooserFchooserInfo instance =
	    (DtbFileChooserFchooserInfo)clientData;
    XmFileSelectionBoxCallbackStruct *cbRec =
	    (XmFileSelectionBoxCallbackStruct *)callData;
    char *path;
    
    path = (char *) _XmStringUngenerate((XmString) cbRec->value, NULL,
	                                XmMULTIBYTE_TEXT, XmMULTIBYTE_TEXT);

    if (!path) {
	    abort();
	    return;
    }
    if ((path != 0) && (path[0] == '\0')) {
	    path = 0;
    }
    XtPointer xtPtr;
    XtVaGetValues( instance->fchooser, XmNuserData, &xtPtr, 0 );
    FileChooserInfo *info = (FileChooserInfo *)xtPtr;
    Widget label = dtb_ttsnoop_ttsnoop_win.ttsnoopWin_label;
    std::ostrstream script;
    switch (info->choice) {
	    Tt_pattern *pats;
	    Tt_message msg;
	    Tt_status status;
	    int ival;
	    char *sess, *val;
	case _DtFileChoosePatternAdd:
	    _DtTtPatternUpdate( (Tt_pattern)info->entity, info->choice, path );
	    break;
	case _DtFileChooseMessageSet:
	    _DtTtMessageUpdate( (Tt_message)info->entity, info->choice, path );
	    break;
	case _DtFileChooseJoin:
	    status = tt_file_join( path );
	    DtTtSetLabel( label, "tt_file_join()", status );
	    break;
	case _DtFileChooseDtJoin:
	    pats = ttdt_file_join( path, TT_SCOPE_NONE, 1, snoopFileMsg, 0 );
	    status = DtTtSetLabel( label, "ttdt_file_join()", pats );
	    if ((status == TT_OK) && (pats != 0)) {
		    DtTtCreated( DTTT_DTFILE, pats, path );
	    }
	    break;
	case _DtFileChooseQuit:
	    status = tt_file_quit( path );
	    DtTtSetLabel( label, "tt_file_quit()", status );
	    break;
	case _DtFileChooseDefault:
	    status = tt_default_file_set( path );
	    DtTtSetLabel( label, "tt_default_file_set()", status );
	    break;
	case _DtFileChooseGetModified:
	    DtTtSetLabel( label, "ttdt_Get_Modified() = ..." );
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, False );
	    ival = ttdt_Get_Modified( 0, path, TT_BOTH,
				      XtWidgetToApplicationContext( label ),
				      globalTimeout );
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, True );
	    DtTtSetLabel( label, "ttdt_Get_Modified()", ival );
	    break;
	case _DtFileChooseSave:
	    DtTtSetLabel( label, "ttdt_Save() = ..." );
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, False );
	    status = ttdt_Save( 0, path, TT_BOTH,
			        XtWidgetToApplicationContext( label ),
			        globalTimeout );
	    // XXX Put up watch cursor; disable dialogs?
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, True );
	    DtTtSetLabel( label, "ttdt_Save()", status );
	    break;
	case _DtFileChooseRevert:
	    DtTtSetLabel( label, "ttdt_Revert() = ..." );
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, False );
	    ival = ttdt_Revert( 0, path, TT_BOTH,
			        XtWidgetToApplicationContext( label ),
			        globalTimeout );
	    XtSetSensitive( dtb_ttsnoop_ttsnoop_win.ttsnoopWin, True );
	    DtTtSetLabel( label, "ttdt_Revert()", ival );
	    break;
	case _DtFileChooseNetfile:
	    val = tt_file_netfile( path );
	    DtTtSetLabel( label, "tt_file_netfile()", val );
	    if (! tt_is_err( tt_ptr_error( val ))) {
		    snoopStream << "tt_file_netfile( \"" << val
			    << "\" ) = \"" << val << "\"" << endl;
	    }
	    break;
	case _DtFileChooseChdir:
	    ival = chdir( path );
	    DtTtSetLabel( label, "chdir()", ival );
	    break;
	case _DtFileChooseTypesLoad:
	    //
	    // Validate types file, with tt_type_comp -p
	    // (A corrupt file could crash ttsession.)
	    //
	    script << "numChars=`tt_type_comp -p \"" << path;
	    script << "\" | wc -c`; if [ $numChars = 0 ]; "
		      "then exit 1; else exit 0; fi" << endl;
	    ival = system( script.str() );
	    delete script.str();
	    if (! WIFEXITED( ival )) {
		    DtTtSetLabel( label,
			"system( \"tt_type_comp -p\" )", ival );
		    break;
	    }
	    if (WEXITSTATUS( ival ) != 0) {
		    std::ostrstream diagnosis;
		    diagnosis << "tt_type_comp -p: syntax error in "
			    << path << ends;
		    DtTtSetLabel( label, diagnosis.str() );
		    delete diagnosis.str();
		    break;
	    }
	    sess = tt_default_session();
	    status = tt_session_types_load( sess, path );
	    tt_free( sess );
	    DtTtSetLabel( label, "tt_session_types_load()", status );
	    break;
	default:
	    break;
    }
    XtUnmanageChild( instance->fchooser_shell );
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}



/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All automatically-generated data and functions have been defined.
 ***
 *** Add new functions here, or at the top of the file.
 ***/

/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/


