/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these libraries and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* $XConsortium: stk.c /main/2 1996/05/08 19:45:44 drk $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*         THIS IS PROPRIETARY SOURCE CODE LICENSED BY          *
*                          AT&T CORP.                          *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*                     All Rights Reserved                      *
*                                                              *
*           This software is licensed by AT&T Corp.            *
*       under the terms and conditions of the license in       *
*       http://www.research.att.com/orgs/ssr/book/reuse        *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                     gsf@research.att.com                     *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include	<sfio_t.h>
#include	<ast.h>
#include	<stk.h>

/*
 *  A stack is a header and a linked list of frames
 *  The first frame has structure
 *	Sfio_t
 *	Sfdisc_t
 *	struct stk
 * Frames have structure
 *	struct frame
 *	data
 */
#define STK_FSIZE	(1024*sizeof(int))
#define STK_HDRSIZE	(sizeof(Sfio_t)+sizeof(Sfdisc_t))

typedef char* (*_stk_overflow_) __PROTO__((int));

static int stkexcept __PROTO__((Sfio_t*,int,Sfdisc_t*));
static Sfdisc_t stkdisc = { 0, 0, 0, stkexcept };

#if _DLL_INDIRECT_DATA && !_DLL
static Sfio_t _Stk_data_data =
#else
Sfio_t _Stk_data =
#endif

SFNEW((char*)0,0,-1,SF_STATIC|SF_WRITE|SF_STRING,&stkdisc);

#if _DLL_INDIRECT_DATA && !_DLL
Sfio_t _Stk_data = &_Stk_data_data;
#endif

struct frame
{
	char	*prev;	/* address of previous frame */
	char	*end;	/* address of end this frame */
};

struct stk
{
	_stk_overflow_	stkoverflow;	/* called when malloc fails */
	short		stkref;	/* reference count; */
	short		stkflags;	/* stack attributes */
	char		*stkbase;	/* beginning of current stack frame */
	char		*stkend;	/* end of current stack frame */
};

static int		init;		/* 1 when initialized */
static struct stk	*stkcur;	/* pointer to current stk */
static char		*stkgrow __PROTO__((Sfio_t*, unsigned));

#define stream2stk(stream)	((stream)==stkstd? stkcur:\
				 ((struct stk*)(((char*)(stream))+STK_HDRSIZE)))
#define stk2stream(sp)		((Sfio_t*)(((char*)(sp))-STK_HDRSIZE))
#define stkleft(stream)		((stream)->endb-(stream)->data)
	

#ifdef STKSTATS
    static struct
    {
	int	create;
	int	delete;
	int	install;
	int	alloc;
	int	copy;
	int	puts;
	int	seek;
	int	set;
	int	grow;
	int	addsize;
	int	delsize;
	int	movsize;
    } _stkstats;
#   define increment(x)	(_stkstats.x++)
#   define count(x,n)	(_stkstats.x += (n))
#else
#   define increment(x)
#   define count(x,n)
#endif /* STKSTATS */

static const char Omsg[] = "malloc failed while growing stack\n";

/*
 * default overflow exception
 */
static char *overflow __PARAM__((int n), (n)) __OTORP__(int n;){
	NoP(n);
	write(2,Omsg, sizeof(Omsg)-1);
	exit(2);
	/* NOTREACHED */
	return(0);
}

/*
 * initialize stkstd, sfio operations may have already occcured
 */
static void stkinit __PARAM__((int size), (size)) __OTORP__(int size;){
	Sfio_t *sp;
	init = size;
	sp = stkopen(0);
	init = 1;
	stkinstall(sp,overflow);
}

static int stkexcept __PARAM__((Sfio_t *stream, int type, Sfdisc_t* dp), (stream, type, dp)) __OTORP__(Sfio_t *stream; int type; Sfdisc_t* dp;){
	NoP(dp);
	switch(type)
	{
	    case SF_CLOSE:
		return(stkclose(stream));
	    case SF_WRITE:
	    case SF_SEEK:
		if(init)
		{
			Sfio_t *old = 0;
			if(stream!=stkstd)
				old = stkinstall(stream,NiL);
			stkgrow(stkstd,sfslen()-(stkstd->endb-stkstd->data));
			if(old)
				stkinstall(old,NiL);
		}
		else
			stkinit(sfslen());
		return(1);
	    case SF_NEW:
		return(-1);
	}
	return(0);
}

/*
 * create a stack
 */
Sfio_t *stkopen __PARAM__((int flags), (flags)) __OTORP__(int flags;){
	int bsize;
	Sfio_t *stream;
	struct stk *sp;
	struct frame *fp;
	Sfdisc_t *dp;
	char *cp;
	if(!(stream=newof((char*)0,Sfio_t, 1, sizeof(*dp)+sizeof(*sp))))
		return(0);
	increment(create);
	count(addsize,sizeof(*stream)+sizeof(*dp)+sizeof(*sp));
	dp = (Sfdisc_t*)(stream+1);
	dp->exceptf = stkexcept;
	sp = (struct stk*)(dp+1);
	sp->stkref = 1;
	sp->stkflags = (flags&STK_SMALL);
	sp->stkoverflow = stkcur?stkcur->stkoverflow:overflow;
	bsize = init+sizeof(struct frame);
#ifndef USE_REALLOC
	if(flags&STK_SMALL)
		bsize = roundof(bsize,STK_FSIZE/16);
	else
#endif /* USE_REALLOC */
		bsize = roundof(bsize,STK_FSIZE);
	bsize -= sizeof(struct frame);
	if(!(fp=newof((char*)0,struct frame, 1,bsize)))
	{
		free(stream);
		return(0);
	}
	count(addsize,sizeof(*fp)+bsize);
	cp = (char*)(fp+1);
	sp->stkbase = (char*)fp;
	fp->prev = 0;
	fp->end = sp->stkend = cp+bsize;
	if(!sfnew(stream,cp,bsize,-1,SF_STRING|SF_WRITE|SF_STATIC|SF_EOF))
		return((Sfio_t*)0);
	sfdisc(stream,dp);
	return(stream);
}

/*
 * return a pointer to the current stack
 * if <stream> is not null, it becomes the new current stack
 * <oflow> becomes the new overflow function
 */
Sfio_t *stkinstall __PARAM__((Sfio_t *stream, _stk_overflow_ oflow), (stream, oflow)) __OTORP__(Sfio_t *stream; _stk_overflow_ oflow;){
	Sfio_t *old;
	struct stk *sp;
	if(!init)
	{
		stkinit(1);
		if(oflow)
			stkcur->stkoverflow = oflow;
		return((Sfio_t*)0);
	}
	increment(install);
	old = stkcur?stk2stream(stkcur):0;
	if(stream)
	{
		sp = stream2stk(stream);
		while(sfstack(stkstd, SF_POPSTACK));
		if(stream!=stkstd)
			sfstack(stkstd,stream);
		stkcur = sp;
#ifdef USE_REALLOC
		/*** someday ***/
#endif /* USE_REALLOC */
	}
	else
		sp = stkcur;
	if(oflow)
		sp->stkoverflow = oflow;
	return(old);
}

/*
 * increase the reference count on the given <stack>
 */
int stklink __PARAM__((Sfio_t* stream), (stream)) __OTORP__(Sfio_t* stream;){
	struct stk *sp = stream2stk(stream);
	return(sp->stkref++);
}

/*
 * terminate a stack and free up the space
 */
int stkclose __PARAM__((Sfio_t* stream), (stream)) __OTORP__(Sfio_t* stream;){
	struct stk *sp = stream2stk(stream);
	char *cp = sp->stkbase;
	struct frame *fp;
	if(--sp->stkref>0)
		return(1);
	increment(delete);
	if(stream==stkstd)
		stkset(stream,(char*)0,0);
	else while(1)
	{
		fp = (struct frame*)cp;
		if(fp->prev)
		{
			cp = fp->prev;
			free(fp);
		}
		else
		{
			free(fp);
			break;
		}
	}
	return(0);
}

/*
 * reset the bottom of the current stack back to <loc>
 * if <loc> is not in this stack, then the stack is reset to the beginning
 * otherwise, the top of the stack is set to stkbot+<offset>
 *
 */
char *stkset __PARAM__((Sfio_t * stream, char* loc, unsigned offset), (stream, loc, offset)) __OTORP__(Sfio_t * stream; char* loc; unsigned offset;){
	struct stk *sp = stream2stk(stream);
	char *cp;
	struct frame *fp;
	int frames = 0;
	if(!init)
		stkinit(offset+1);
	increment(set);
	while(1)
	{
		/* see whether <loc> is in current stack frame */
		if(loc>=(cp=sp->stkbase) && loc<=sp->stkend)
		{
			cp += sizeof(struct frame);
			if(frames)
				sfsetbuf(stream,cp,sp->stkend-cp);
			stream->data = (unsigned char*)(cp + roundof(loc-cp,sizeof(char*)));
			stream->next = (unsigned char*)loc+offset;
			goto found;
		}
		fp = (struct frame*)cp;
		if(fp->prev)
		{
			sp->stkbase = fp->prev;
			sp->stkend = ((struct frame*)(fp->prev))->end;
			free(cp);
		}
		else
			break;
		frames++;
	}
	/* set stack back to the beginning */
	cp = (char*)(fp+1);
	if(frames)
		sfsetbuf(stream,cp,sp->stkend-cp);
	else
		stream->data = stream->next = (unsigned char*)cp;
found:
	return((char*)stream->data);
}

/*
 * allocate <n> bytes on the current stack
 */
char *stkalloc __PARAM__((Sfio_t *stream, unsigned int n), (stream, n)) __OTORP__(Sfio_t *stream; unsigned int n;){
	unsigned char *old;
	if(!init)
		stkinit(n);
	increment(alloc);
	n = roundof(n,sizeof(char*));
	if(stkleft(stream) <= (int)n)
		stkgrow(stream,n);
	old = stream->data;
	stream->data = stream->next = old+n;
	return((char*)old);
}

/*
 * begin a new stack word of at least <n> bytes
 */
char *_stkseek __PARAM__((Sfio_t *stream, unsigned n), (stream, n)) __OTORP__(Sfio_t *stream; unsigned n;){
	if(!init)
		stkinit(n);
	increment(seek);
	if(stkleft(stream) <= (int)n)
		stkgrow(stream,n);
	stream->next = stream->data+n;
	return((char*)stream->data);
}

/*
 * advance the stack to the current top
 * if extra is non-zero, first add a extra bytes and zero the first
 */
char	*stkfreeze __PARAM__((Sfio_t *stream, unsigned extra), (stream, extra)) __OTORP__(Sfio_t *stream; unsigned extra;){
	unsigned char *old, *top;
	if(!init)
		stkinit(extra);
	old = stream->data;
	top = stream->next;
	if(extra)
	{
		if(extra > (stream->endb-stream->next))
		{
			top = (unsigned char*)stkgrow(stream,extra);
			old = stream->data;
		}
		*top = 0;
		top += extra;
	}
	stream->next = stream->data += roundof(top-old,sizeof(char*));
	return((char*)old);
}

/*
 * copy string <str> onto the stack as a new stack word
 */
char	*stkcopy __PARAM__((Sfio_t *stream, const char* str), (stream, str)) __OTORP__(Sfio_t *stream; const char* str;){
	unsigned char *cp = (unsigned char*)str;
	int n;
	while(*cp++);
	n = roundof(cp-(unsigned char*)str,sizeof(char*));
	if(!init)
		stkinit(n);
	increment(copy);
	if(stkleft(stream) <= n)
		stkgrow(stream,n);
	strcpy((char*)(cp=stream->data),str);
	stream->data = stream->next = cp+n;
	return((char*)cp);
}

/*
 * add a new stack frame of size >= <n> to the current stack.
 * if <n> > 0, copy the bytes from stkbot to stktop to the new stack
 * if <n> is zero, then copy the remainder of the stack frame from stkbot
 * to the end is copied into the new stack frame
 */

static char *stkgrow __PARAM__((Sfio_t *stream, unsigned size), (stream, size)) __OTORP__(Sfio_t *stream; unsigned size;){
	int n = size;
	struct stk *sp = stream2stk(stream);
	struct frame *fp;
	char *cp;
	unsigned m = stktell(stream);
	int reused = 0;
	n += (m + sizeof(struct frame)+1);
	if(sp->stkflags&STK_SMALL)
#ifndef USE_REALLOC
		n = roundof(n,STK_FSIZE/16);
	else
#endif /* !USE_REALLOC */
		n = roundof(n,STK_FSIZE);
	/* see whether current frame can be extended */
	if((char*)(stream->data) == sp->stkbase+sizeof(struct frame))
	{
		cp = newof(sp->stkbase,char,n,0);
		reused++;
	}
	else
		cp = newof((char*)0, char, n, 0);
	if(!cp) cp = (*sp->stkoverflow)(n);
	increment(grow);
	count(addsize,n);
	fp = (struct frame*)cp;
	if(!reused)
	{
		fp->prev = sp->stkbase;
	}
	sp->stkbase = cp;
	sp->stkend = fp->end = cp+n;
	cp = (char*)(fp+1);
	if(m && !reused)
		memcpy(cp,(char*)stream->data,m);
	count(movsize,m);
	sfsetbuf(stream,cp,sp->stkend-cp);
	return((char*)(stream->next = stream->data+m));
}

