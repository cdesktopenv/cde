/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these librararies and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* $XConsortium: pax.h /main/3 1995/11/01 17:02:18 rswiston $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*         THIS IS PROPRIETARY SOURCE CODE LICENSED BY          *
*                          AT&T CORP.                          *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*                     All Rights Reserved                      *
*                                                              *
*           This software is licensed by AT&T Corp.            *
*       under the terms and conditions of the license in       *
*       http://www.research.att.com/orgs/ssr/book/reuse        *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                     gsf@research.att.com                     *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include <ast.h>
#include <ls.h>
#include <sig.h>
#include <ftwalk.h>
#include <ctype.h>
#include <hash.h>
#include <proc.h>
#include <re.h>
#include <error.h>
#include <times.h>
#include <swap.h>
#include <align.h>
#include <modex.h>
#include <sfstr.h>
#include <debug.h>

#include <stdio.h>

#if !defined(va_start)
#if defined(__STDARG__)
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#endif


#define PANIC		ERROR_PANIC|ERROR_SOURCE,__FILE__,__LINE__

#define bcount(ap)	((ap)->io.last-(ap)->io.next)
#define bsave(ap)	(state.backup=(ap)->io)

#define BUFFER_FD_MAX	(-2)
#define BUFFER_FD_MIN	(-3)

#define getbuffer(n)	(((n)>=BUFFER_FD_MIN&&(n)<=BUFFER_FD_MAX)?&state.buffer[BUFFER_FD_MAX-(n)]:(Buffer_t*)0)
#define setbuffer(n)	(BUFFER_FD_MAX-(n))

#define HOLE_MIN	1024

#define holeinit(fd)	(state.hole=0)
#define holedone(fd)	do if(state.hole){lseek(fd,state.hole-1,SEEK_CUR);state.hole=0;write(fd,"",1);} while(0)

#define RE_STOP		(1<<(RE_EXTERNAL+0))	/* stop on success	*/
#define RE_VERBOSE	(1<<(RE_EXTERNAL+1))	/* list result		*/

/*
 * info per archive format
 *
 * NOTES:
 *
 *	format indices must agree with format[] table below
 *
 *	the *_NAMESIZE maximum file name lengths include the trailing \0
 *
 *	PATH_MAX must be >= max(*_NAMESIZE)
 */

#define ALAR		0
#define ALAR_NAME	"ansi"
#define ALAR_REGULAR	4
#define ALAR_SPECIAL	ALAR_REGULAR
#define ALAR_LABEL	2048
#define ALAR_HEADER	80
#define ALAR_VARHDR	9
#define ALAR_NAMESIZE	17
#define ALAR_RECSIZE	(BLOCKSIZE>>2)
#define ALAR_RECFORMAT	'D'
#define ALAR_ALIGN	0
#define ALAR_FLAGS	IN|OUT
#define ALAR_ID		"SLT"

#define BINARY		1
#define BINARY_NAME	"binary"
#define BINARY_REGULAR	DEFBUFFER
#define BINARY_SPECIAL	DEFBLOCKS
#define BINARY_HEADER	26
#define BINARY_NAMESIZE	256
#define BINARY_ALIGN	2
#define BINARY_FLAGS	IN|OUT

typedef struct				/* binary header		*/
{
	short		magic;
	unsigned short	dev;
	unsigned short	ino;
	unsigned short	mode;
	unsigned short	uid;
	unsigned short	gid;
	short		links;
	unsigned short	rdev;
	unsigned short	mtime[2];
	short		namesize;
	unsigned short	size[2];
} Hdr_binary_t;

#define CPIO		2
#define CPIO_NAME	"cpio"
#define CPIO_REGULAR	DEFBUFFER
#define CPIO_SPECIAL	DEFBLOCKS
#define CPIO_HEADER	76
#define CPIO_MAGIC	070707
#define CPIO_EXTENDED	1
#define CPIO_TRAILER	"TRAILER!!!"
#define CPIO_TRUNCATE(x) ((x)&0177777)
#define CPIO_NAMESIZE	256
#define CPIO_ALIGN	0
#define CPIO_FLAGS	IN|OUT

#define IBMAR		3
#define IBMAR_NAME	"ibm"
#define IBMAR_REGULAR	ALAR_REGULAR
#define IBMAR_SPECIAL	ALAR_SPECIAL
#define IBMAR_ALIGN	ALAR_ALIGN
#define IBMAR_FLAGS	IN|OUT

/*
 * NOTE: since USTAR is an extension of TAR they share the same header
 */

#define TAR		4
#define TAR_NAME	"tar"
#define TAR_REGULAR	DEFBUFFER
#define TAR_SPECIAL	DEFBLOCKS
#define TAR_HEADER	TBLOCK
#define TAR_NAMESIZE	100
#define TAR_ALIGN	BLOCKSIZE
#define TAR_FLAGS	IN|OUT

#define header		tar_header_info
#define hblock		tar_header_block
#include <tar.h>
#undef header
#undef hblock

typedef union tar_header_block Hdr_tar_t;

#define USTAR		5
#define USTAR_NAME	TMAGIC
#define USTAR_REGULAR	TAR_REGULAR
#define USTAR_SPECIAL	TAR_SPECIAL
#define USTAR_HEADER	TAR_HEADER
#define USTAR_ALIGN	TAR_ALIGN
#define USTAR_FLAGS	IN|OUT

#define tar_header	tar_header_block.dbuf
#define tar_block	tar_header_block.dummy

/*
 * s5r4 expanded cpio(5) char format
 * pax won't even bother with the binary counterpart
 */

#define ASC		6
#define ASC_NAME	"asc"
#define ASC_REGULAR	CPIO_REGULAR
#define ASC_SPECIAL	CPIO_SPECIAL
#define ASC_HEADER	110
#define ASC_MAGIC	070701
#define ASC_NAMESIZE	1024
#define ASC_ALIGN	4
#define ASC_FLAGS	IN|OUT

/*
 * s5r4 expanded cpio(5) char format with checksum
 * (misnamed ``crc'' -- the check is a simple sum of the header)
 * pax won't even bother with the binary counterpart
 */

#define ASCHK		7
#define ASCHK_NAME	"aschk"
#define ASCHK_REGULAR	ASC_REGULAR
#define ASCHK_SPECIAL	ASC_SPECIAL
#define ASCHK_MAGIC	070702
#define ASCHK_ALIGN	ASC_ALIGN
#define ASCHK_FLAGS	IN|OUT

/*
 * backup saveset format
 */

#define SAVESET		8
#define SAVESET_NAME	"vmsbackup"
#define SAVESET_REGULAR	0
#define SAVESET_SPECIAL	0
#define SAVESET_ALIGN	0
#define SAVESET_FLAGS	IN
#define SAVESET_ID	"DECVMS"
#define SAVESET_IMPL	"BACKUP"

#define BLKHDR_SIZE	256
#define BLKHDR_hdrsiz	0
#define BLKHDR_blksiz	40

#define FILHDR_SIZE	4
#define FILHDR_MAGIC	257
#define FILHDR_namelen	128
#define FILHDR_size	0
#define FILHDR_type	2
#define FILHDR_data	4

#define FILATT_blocks	10
#define FILATT_frag	12
#define FILATT_recatt	1
#define FILATT_recfmt	0
#define FILATT_reclen	2
#define FILATT_recvfc	15

#define RECHDR_SIZE	16
#define RECHDR_size	0
#define RECHDR_type	2

#define REC_file	3
#define REC_vbn		4

/*
 * the proposed POSIX IEEE Std 1003.1B-1990 interchange format
 */

#define PAX		9
#define PAX_NAME	"pax"
#define PAX_REGULAR	TAR_REGULAR
#define PAX_SPECIAL	TAR_SPECIAL
#define PAX_HEADER	TAR_HEADER
#define PAX_ALIGN	TAR_ALIGN
#define PAX_FLAGS	IN|OUT

/*
 * portable (object) archive
 */

#define PORTAR		10
#define PORTAR_NAME	"portarch"
#define PORTAR_REGULAR	0
#define PORTAR_SPECIAL	0
#define PORTAR_HEADER	sizeof(portar_header)
#define PORTAR_MAG	"!<arch>\n"
#define PORTAR_MAGSIZ	8
#define PORTAR_SYM	"(/ |__________E???_)*"
#define PORTAR_END	"`\n"
#define PORTAR_ENDSIZ	2
#define PORTAR_TERM	'/'
#define PORTAR_ALIGN	2
#define PORTAR_FLAGS	IN

typedef struct			/* portar header			*/
{
	char	ar_name[16];
	char	ar_date[12];	/* left-adj; decimal char*; blank fill	*/
	char	ar_uid[6];	/*	"				*/
	char	ar_gid[6];	/*	"				*/
	char	ar_mode[8];	/* left-adj; octal char*; blank fill	*/
	char	ar_size[10];	/* left-adj; decimal char*; blank fill	*/
	char	ar_fmag[2];	/* PORTAR_END				*/
} Hdr_portar_t;

/*
 * ranlib (object) archive -- almost PORTAR
 */

#define RANDAR		11
#define RANDAR_NAME	"randarch"
#define RANDAR_REGULAR	0
#define RANDAR_SPECIAL	0
#define RANDAR_SYM	"(__.SYMDEF|__________E???X)*"
#define RANDAR_TERM	' '
#define RANDAR_ALIGN	PORTAR_ALIGN
#define RANDAR_FLAGS	IN

/*
 * cql virtual directory archive
 */

#include <vdb.h>

#define VDB		12
#define VDB_NAME	VDB_MAGIC
#define VDB_REGULAR	DEFBUFFER
#define VDB_SPECIAL	DEFBLOCKS
#define VDB_ALIGN	0
#define VDB_FLAGS	IN|OUT

/*
 * compression pseudo formats -- COMPRESS is first
 */

#define COMPRESS		13
#define COMPRESS_NAME		"compress"
#define COMPRESS_ALGORITHM	0
#define COMPRESS_UNDO		"zcat"
#define COMPRESS_MAGIC		0x1f9d

#define GZIP			14
#define GZIP_NAME		"gzip"
#define GZIP_ALGORITHM		"-9"
#define GZIP_UNDO		"gunzip"
#define GZIP_MAGIC		0x1f8b

/*
 * delta pseudo formats -- DELTA is first
 */

#define DELTA			15
#define DELTA_NAME		"delta"
#define DELTA_ALGORITHM		"94"

#define DELTA_88		16
#define DELTA_88_NAME		"delta88"
#define DELTA_88_ALGORITHM	"88"

#define DELTA_IGNORE		17
#define DELTA_IGNORE_NAME	"ignore"

#define DELTA_PATCH		18
#define DELTA_PATCH_NAME	"patch"

/*
 * format generic definitions
 */

#define IN_DEFAULT	CPIO		/* first getheader() state	*/
#define OUT_DEFAULT	CPIO		/* default output format	*/

#define IN		(1<<0)		/* copy in			*/
#define OUT		(1<<1)		/* copy out			*/

#define SETIDS		(1<<0)		/* set explicit uid and gid	*/

#define INFO_MATCH	"*([A-Z0-9!])!!!"/* info header file name match	*/
#define INFO_SEP	'!'		/* info header field separator	*/
#define INFO_ORDERED	'O'		/* delta on ordered base	*/

#define ID		"PAX"		/* info header id		*/
#define IDLEN		(sizeof(ID)-1)	/* strlen(ID)			*/

#define IMPLEMENTATION	"ATTPAX1"	/* implementation id		*/

#define TYPE_COMPRESS	'C'		/* compress encoding type	*/
#define TYPE_DELTA	'D'		/* delta encoding type		*/

#define DELTA_SRC	0		/* source info			*/
#define DELTA_TAR	1		/* target info			*/
#define DELTA_DEL	2		/* delta info			*/
#define DELTA_DATA	3		/* data info mask		*/
#define DELTA_BIO	(1<<2)		/* bio (no arg)			*/
#define DELTA_BUFFER	(1<<3)		/* buffer arg			*/
#define DELTA_FD	(1<<4)		/* fd arg			*/
#define DELTA_HOLE	(1<<5)		/* holewrite() fd arg		*/
#define DELTA_OFFSET	(1<<6)		/* offset arg			*/
#define DELTA_SIZE	(1<<7)		/* size arg			*/
#define DELTA_OUTPUT	(1<<8)		/* output data			*/
#define DELTA_TEMP	(1<<9)		/* temp output fd		*/
#define DELTA_FREE	(1<<10)		/* free fd or buffer		*/
#define DELTA_COUNT	(1<<11)		/* set in|out count		*/
#define DELTA_LIST	(1<<12)		/* listentry() if ok		*/

#define DELTA_create	'c'		/* delta create data op		*/
#define DELTA_delete	'd'		/* delta delete data op		*/
#define DELTA_nop	'x'		/* no delta operation pseudo op	*/
#define DELTA_pass	'p'		/* delta pass pseudo op		*/
#define DELTA_update	'u'		/* delta update data op		*/
#define DELTA_verify	'v'		/* delta verify data op		*/

#define DELTA_TRAILER	10		/* delta trailer output size	*/

#define DELTA_checksum	'c'		/* delta member checksum	*/
#define DELTA_index	'i'		/* delta header index		*/
#define DELTA_trailer	't'		/* delta trailer size		*/

#define DELTA_LO(c)	((c)&0xffff)	/* lo order checksum bits	*/
#define DELTA_HI(c)	DELTA_LO(c>>16)	/* hi order checksum bits	*/

#define INVALID_ignore		0	/* silently ignore		*/
#define INVALID_prompt		1	/* prompt for new name		*/
#define INVALID_translate	2	/* translate and/or truncate	*/
#define INVALID_UTF8		3	/* convert to UTF8		*/

#define NOLINK		0		/* not a link			*/
#define HARDLINK	'1'		/* hard link to previous entry	*/
#define SOFTLINK	'2'		/* soft link to previous entry	*/

#define BLOCKSIZE	512		/* block size			*/
#define IOALIGN		ALIGN_BOUND1	/* io buffer alignment		*/
#define MINBLOCK	1		/* smallest block size		*/
#define DEFBLOCKS	20		/* default blocking		*/
#define DEFBUFFER	16		/* default io buffer blocking	*/
#define MAXBLOCKS	40		/* largest blocking		*/
#define MAXUNREAD	BLOCKSIZE	/* max bunread() count		*/
#define RESETABLE	(-1)		/* default option can be reset	*/

typedef struct				/* buffered io info		*/
{
	char*		next;		/* next char pointer		*/
	char*		last;		/* last char+1 pointer		*/
	char*		buffer;		/* io buffer			*/
	unsigned long	count;		/* char transfer count		*/
	unsigned long	offset;		/* volume offset		*/
	int		fd;		/* file descriptor		*/
	int		skip;		/* volume skip			*/
	int		keep;		/* volume keep after skip	*/
	int		mode;		/* open() O_* mode		*/
	unsigned int	all:1;		/* read all volumes		*/
	unsigned int	blocked:1;	/* blocked device io		*/
	unsigned int	blok:1;		/* BLOK io file			*/
	unsigned int	blokflag:1;	/* io file BLOK flag		*/
	unsigned int	empty:1;	/* last read was empty		*/
	unsigned int	eof:1;		/* hit EOF			*/
	unsigned int	seekable:1;	/* seekable			*/
	unsigned int	seekcheck:1;	/* checked if seekable		*/
	unsigned int	unblocked:1;	/* set unblocked device io	*/
} Bio_t;

typedef struct				/* pseudo fd buffer		*/
{
	char*		base;		/* buffer base			*/
	char*		next;		/* current position		*/
	char*		past;		/* overflow position		*/
} Buffer_t;

typedef struct				/* common internal file info	*/
{
	struct Archive*	ap;		/* !=0 if from buffer		*/
	int		extended;	/* extended header file		*/
	int		fd;		/* >=0 read fd			*/
	char*		id;		/* archive file id		*/
	int		magic;		/* header magic number		*/
	char*		name;		/* archive file name		*/
	int		namesize;	/* name size with null byte	*/
	char*		path;		/* local file name for reading	*/
	int		perm;		/* original st_mode perm	*/
	struct
	{
	int		op;		/* op				*/
	struct Member* 	base;		/* base file pointer		*/
	long		size;		/* target file size		*/
	}		delta;		/* delta info			*/
	struct stat*	st;		/* stat() info from ftwalk()	*/
	int		type;		/* st_mode type			*/
	int		linktype;	/* NOLINK, HARDLINK, SOFTLINK	*/
	char*		linkname;	/* link to this path		*/
	int		linknamesize;	/* linkname size with null byte	*/
	char*		uidname;	/* user id name			*/
	char*		gidname;	/* group id name		*/
	struct
	{
	int		blocks;		/* io block count		*/
	int		format;		/* format			*/
	int		section;	/* file section number		*/
	}		record;		/* record format info		*/
	long		checksum;	/* checksum			*/
	unsigned int	ordered:1;	/* ordered fileout() override	*/
	unsigned int	skip:1;		/* skip this entry		*/
} File_t;

typedef struct Member			/* cached member info		*/
{
	File_t* 	info;		/* deltapass() file info	*/
	short		dev;		/* dev				*/
	short		ino;		/* ino				*/
	long		mtime;		/* modify time			*/
	long		offset;		/* data offset			*/
	long		size;		/* data size			*/
	long		expand;		/* expanded size		*/
	unsigned int	mark:1;		/* visit mark			*/
} Member_t;

typedef struct				/* unique file identifier	*/
{
	int		dev;		/* device			*/
	int		ino;		/* inode			*/
} Fileid_t;

typedef struct				/* format info			*/
{
	char*		name;		/* name				*/
	int		regular;	/* default regular blocking	*/
	int		special;	/* default special blocking	*/
	int		align;		/* trailer alignment		*/
	int		flags;		/* io info			*/
	char*		algorithm;	/* compress algorithm name/flag	*/
	char*		undo;		/* compress undo name		*/
} Format_t;

typedef struct				/* link info			*/
{
	char*		name;		/* name				*/
	int		namesize;	/* name size with null byte	*/
	Fileid_t	id;		/* generated link file id	*/
} Link_t;

typedef struct List			/* generic list			*/
{
	struct List*	next;		/* next in list			*/
	__V_*		item;		/* list item pointer		*/
} List_t;

typedef struct Map			/* file name map list		*/
{
	struct Map*	next;		/* next in list			*/
	reprogram*	re;		/* compiled match re		*/
	char*		into;		/* map into this		*/
	int		flags;		/* resub() flags		*/
} Map_t;

typedef struct				/* post processing restoration	*/
{
	time_t		mtime;		/* modify time			*/
	int		mode;		/* permissions			*/
	int		uid;		/* user id			*/
	int		gid;		/* group id			*/
} Post_t;

typedef union				/* byte|half swap probe		*/
{
	unsigned long	l;
	unsigned short	s[2];
	unsigned char	c[4];
} Integral_t;

typedef struct				/* delta archive info		*/
{
	struct Archive*	base;		/* base archive			*/
	int		epilogue;	/* epilogue hit			*/
	int		index;		/* member index			*/
	int		format;		/* 0,DELTA,DELTA_IGNORE,DELTA_PATCH */
	char*		hdr;		/* header pointer		*/
	char		hdrbuf[64];	/* header buffer		*/
	Hash_table_t*	tab;		/* entry table			*/
	int		trailer;	/* optional trailer size	*/
	int		version;	/* encoding type version	*/
} Delta_t;

typedef struct Archive			/* archive info			*/
{
	unsigned long	checksum;	/* running checksum		*/
	int		compress;	/* compression index		*/
	Delta_t*	delta;		/* delta info			*/
	int		entries;	/* total number of entries	*/
	int		entry;		/* current entry index		*/
	File_t		file;		/* current member file info	*/
	int		format;		/* format			*/
	Bio_t		io;		/* buffered io info		*/
	unsigned long	memsum;		/* checksum			*/
	char*		name;		/* io pathname			*/
	char*		names;		/* PORTAR long name directory	*/
	long		offset;		/* relative byte offset		*/
	struct
	{
	unsigned long	checksum;	/* old running checksum		*/
	unsigned long	memsum;		/* old checksum			*/
	}		old;
	struct
	{
	char		header[PATH_MAX*2];/* header path name		*/
	char		link[PATH_MAX];	/* link text			*/
	char		name[PATH_MAX];	/* real path name		*/
	char		prev[PATH_MAX];	/* previous entry order check	*/
	}		path;
	struct Archive*	parent;		/* parent (delta) for base	*/
	int		part;		/* media change count		*/
	int		pass;		/* virtual			*/
	int		peek;		/* already peeked at file entry */
	int		selected;	/* number of selected members	*/
	unsigned long	size;		/* size				*/
	unsigned long	skip;		/* base archive skip offset	*/
	struct stat	st;		/* memver stat			*/
	int		sum;		/* collect running checksum	*/
	int		swap;		/* swap operation		*/
	File_t*		record;		/* record output file		*/
	int		volume;		/* volume number		*/
} Archive_t;

typedef struct				/* program state		*/
{
	int		acctime;	/* reset file access times	*/
	int		append;		/* append -- must be 0 or 1 !!!	*/
	Bio_t		backup;		/* backup() position		*/
	int		blocksize;	/* explicit buffer size		*/
	Buffer_t	buffer[BUFFER_FD_MAX-BUFFER_FD_MIN+1];/* fd buf	*/
	int		buffersize;	/* io buffer size		*/
	int		clobber;	/* overwrite output files	*/
	int		complete;	/* files completely in volume	*/
	int		current;	/* current file[] index		*/
	int		descend;	/* dir names self+descendents	*/
	char*		destination;	/* pass mode destination dir	*/
	dev_t		dev;		/* . device number		*/
	unsigned short	devcnt;		/* dev assignment count		*/
	int		drop;		/* drop a `.' for each file	*/
	int		dropcount;	/* current line drop count	*/
	int		exact;		/* exact archive read		*/
	char**		files;		/* alternate file name list	*/
	char**		filter;		/* file output filter command	*/
	char**		filterarg;	/* filter file arg		*/
	int		flags;		/* flags			*/
	int		ftwflags;	/* ftwalk() flags		*/
	int		gid;		/* current group id		*/
	struct
	{
	char*		comment;	/* comment text			*/
	int		invalid;	/* invalid path INVALID_ action	*/
	int		linkdata;	/* data with each hard link	*/
	char*		listformat;	/* verbose listing format	*/
	char*		name;		/* name format			*/
	}		header;		/* header specific options	*/
	off_t		hole;		/* one past last hole		*/
	struct
	{
	char		volume[64];	/* volume id			*/
	char		format[7];	/* format id			*/
	char		implementation[8];/* implementation id		*/
	char		owner[15];	/* owner id			*/
	char		standards[20];	/* standards id			*/
	}		id;		/* id strings (including '\0')	*/
	Archive_t*	in;		/* input archive info		*/
	unsigned short	inocnt;		/* ino assignment count		*/
	int		intermediate;	/* make intermediate dirs	*/
	int		interrupt;	/* this signal caused exit	*/
	int		keepgoing;	/* keep going on error		*/
					/* use when possible for -rw	*/
	int		(*linkf) __PROTO__((const char*, const char*));
	Hash_table_t*	linktab;	/* hard link table		*/
	int		list;		/* full file trace		*/
	char*		listformat;	/* verbose listing format	*/
	Map_t*		maps;		/* file name maps		*/
	int		matchsense;	/* pattern match sense		*/
	unsigned long	maxout;		/* max volume/part output count	*/
	int		modemask;	/* & with mode for chmod()	*/
	int		modtime;	/* retain mtime			*/
	int		newer;		/* append only if newer		*/
	int		operation;	/* IN|OUT operation mode	*/
	Hash_table_t*	options;	/* option table			*/
	int		ordered;	/* sorted base and file list	*/
	int		owner;		/* set owner info		*/
	Archive_t*	out;		/* output archive info		*/
	char**		patterns;	/* name match patterns		*/
	char*		peekfile;	/* stdin file list peek		*/
	char		pwd[PATH_MAX];	/* full path of .		*/
	int		pwdlen;		/* pwd length sans null		*/
	List_t*		proc;		/* procopen() list for finish	*/
	struct
	{
	int		charset;	/* convert record charset	*/
	int		delimiter;	/* directory delimiter		*/
	File_t* 	file;		/* current output file		*/
	int		format;		/* record format		*/
	char*		header;		/* file header			*/
	int		headerlen;	/* file header length		*/
	int		line;		/* convert records<->lines	*/
	int		pad;		/* pad output record blocks	*/
	char*		pattern;	/* format match pattern		*/
	int		offset;		/* data buffer offset		*/
	int		size;		/* io size			*/
	char*		trailer;	/* file trailer			*/
	int		trailerlen;	/* file trailer length		*/
	}		record;		/* record info			*/
	Hash_table_t*	restore;	/* post proc restoration table	*/
	Sfio_t*		rtty;		/* tty file read pointer	*/
#if SAVESET
	struct
	{
	char*		block;		/* current block		*/
	int		blocksize;	/* max block size		*/
	char*		bp;		/* block pointer		*/
	int		recatt;		/* record attributes		*/
	int		recfmt;		/* record format		*/
	int		reclen;		/* record length		*/
	int		recvfc;		/* record fixed control length	*/
	int		lastsize;	/* size of last record		*/
	time_t		time;		/* backup time			*/
	}		saveset;	/* backup saveset state		*/
#endif
	int		setgid;		/* set file gid to this value	*/
	int		setuid;		/* set file uid to this value	*/
					/* -L=pathstat() -P=lstat()	*/
	int		(*statf) __PROTO__((const char*, struct stat*));
	int		summary;	/* output summary info		*/
	int		test;		/* debug test bits		*/
	struct
	{
	char*		buffer;		/* temporary buffer		*/
	int		buffersize;	/* temporary buffer size	*/
	char*		file;		/* tmp file name		*/
	}		tmp;		/* temporary stuff		*/
	int		uid;		/* current user id		*/
	int		update;		/* copy file only if newer	*/
	struct
	{
	unsigned char	delimiter;	/* header delimiter		*/
	unsigned char	variant;	/* variant header delimiters	*/
	Sfio_t*		directory;	/* directory trailer stream	*/
	struct stat	st;		/* member stat prototype	*/
	struct
	{
	char*		base;		/* header buffer base		*/
	char*		next;		/* next header			*/
	}		header;
	}		vdb;
	int		verbose;	/* trace files when acted upon	*/
	int		verify;		/* verify action on file	*/
	Sfio_t*		wtty;		/* tty file write pointer	*/
	int		xdev;		/* don't cross device boundaries*/
	int		yesno;		/* interactive answer is yes/no	*/
} State_t;

extern __MANGLE__ char*			definput;
extern __MANGLE__ char*			defoutput;
extern __MANGLE__ char*			eomprompt;
extern __MANGLE__ char			uidname[];
extern __MANGLE__ char			gidname[];
extern __MANGLE__ Format_t			format[];
extern __MANGLE__ State_t			state;

extern __MANGLE__ char			alar_header[ALAR_LABEL];
extern __MANGLE__ Hdr_binary_t		binary_header;
extern __MANGLE__ Hdr_portar_t		portar_header;
extern __MANGLE__ Hdr_tar_t		tar_header_block;

extern __MANGLE__ void		adddelnum __PROTO__((int, long));
extern __MANGLE__ void		adddelstr __PROTO__((int, char*));
extern __MANGLE__ int		addlink __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		append __PROTO__((Archive_t*));
extern __MANGLE__ long		asc_checksum __PROTO__((char*, int, unsigned long));
extern __MANGLE__ void		backup __PROTO__((Archive_t*));
extern __MANGLE__ void		bflushin __PROTO__((Archive_t*));
extern __MANGLE__ void		bflushout __PROTO__((Archive_t*));
extern __MANGLE__ char*		bget __PROTO__((Archive_t*, int));
extern __MANGLE__ void		binit __PROTO__((Archive_t*));
extern __MANGLE__ void		bput __PROTO__((Archive_t*, int));
extern __MANGLE__ int		bread __PROTO__((Archive_t*, __V_*, long, long, int));
extern __MANGLE__ off_t		bseek __PROTO__((Archive_t*, off_t, int));
extern __MANGLE__ int		bskip __PROTO__((Archive_t*));
extern __MANGLE__ void		bunread __PROTO__((Archive_t*, __V_*, int));
extern __MANGLE__ void		bwrite __PROTO__((Archive_t*, __V_*, int));
extern __MANGLE__ int		cmpftw __PROTO__((Ftw_t*, Ftw_t*));
extern __MANGLE__ void		copy __PROTO__((Archive_t*, int(*)(Ftw_t*)));
extern __MANGLE__ void		copyin __PROTO__((Archive_t*));
extern __MANGLE__ int		copyinout __PROTO__((Ftw_t*));
extern __MANGLE__ int		copyout __PROTO__((Ftw_t*));
extern __MANGLE__ long		cpio_long __PROTO__((unsigned short*));
extern __MANGLE__ void		cpio_short __PROTO__((unsigned short*, long));
extern __MANGLE__ int		delta __PROTO__((char*, long, char*, long, int));
extern __MANGLE__ void		deltabase __PROTO__((Archive_t*));
extern __MANGLE__ void		deltadelete __PROTO__((Archive_t*));
extern __MANGLE__ void		deltaout __PROTO__((Archive_t*, Archive_t*, File_t*));
extern __MANGLE__ void		deltapass __PROTO__((Archive_t*, Archive_t*));
extern __MANGLE__ void		deltaverify __PROTO__((Archive_t*));
extern __MANGLE__ int		dirprefix __PROTO__((char*, char*));
extern __MANGLE__ void		filein __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		fileout __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		fileskip __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ int		filter __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		finish __PROTO__((int));
extern __MANGLE__ Archive_t*	getarchive __PROTO__((int));
extern __MANGLE__ void		getdeltaheader __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		getepilogue __PROTO__((Archive_t*));
extern __MANGLE__ int		getfile __PROTO__((Archive_t*, File_t*, Ftw_t*));
extern __MANGLE__ int		getformat __PROTO__((char*));
extern __MANGLE__ int		getheader __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		getidnames __PROTO__((File_t*));
extern __MANGLE__ int		getlabel __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ long		getlabnum __PROTO__((char*, int, int, int));
extern __MANGLE__ char*		getlabstr __PROTO__((char*, int, int, char*));
extern __MANGLE__ int		getprologue __PROTO__((Archive_t*));
extern __MANGLE__ int		getsaveset __PROTO__((Archive_t*, File_t*, int));
extern __MANGLE__ void		gettrailer __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ ssize_t		holewrite __PROTO__((int, __V_*, size_t));
extern __MANGLE__ Archive_t*	initarchive __PROTO__((const char*, int));
extern __MANGLE__ void		initdelta __PROTO__((Archive_t*));
extern __MANGLE__ void		initfile __PROTO__((Archive_t*, File_t*, char*, int));
extern __MANGLE__ char**		initmatch __PROTO__((char**));
extern __MANGLE__ void		interactive __PROTO__((void));
extern __MANGLE__ void		listentry __PROTO__((File_t*));
extern __MANGLE__ int		listprintf __PROTO__((Sfio_t*, Archive_t*, File_t*, const char*));
extern __MANGLE__ char*		map __PROTO__((char*));
extern __MANGLE__ int		match __PROTO__((char*));
extern __MANGLE__ void		newio __PROTO__((Archive_t*, int, int));
extern __MANGLE__ unsigned long	omemsum __PROTO__((const __V_*, int, unsigned long));
extern __MANGLE__ int		openin __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ int		openout __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ int		paxdelta __PROTO__((Archive_t*, Archive_t*, File_t*, int, ...));
extern __MANGLE__ int		portable __PROTO__((const char*));
extern __MANGLE__ int		prune __PROTO__((Archive_t*, File_t*, struct stat*));
extern __MANGLE__ void		putdeltaheader __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		putepilogue __PROTO__((Archive_t*));
extern __MANGLE__ void		putheader __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		putlabels __PROTO__((Archive_t*, File_t*, char*));
extern __MANGLE__ void		putprologue __PROTO__((Archive_t*));
extern __MANGLE__ void		puttrailer __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ int		restore __PROTO__((const char*, char*, __V_*));
extern __MANGLE__ int		selectfile __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		setdeltaheader __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		setfile __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ void		setidnames __PROTO__((File_t*));
extern __MANGLE__ int		setoption __PROTO__((__V_*, const __V_*, int, const char*));
extern __MANGLE__ void		settime __PROTO__((const char*, time_t, time_t));
extern __MANGLE__ char*		strlower __PROTO__((char*));
extern __MANGLE__ char*		strupper __PROTO__((char*));
extern __MANGLE__ int		tar_checksum __PROTO__((void));
extern __MANGLE__ int		update __PROTO__((int, long, int, int));
extern __MANGLE__ int		validout __PROTO__((Archive_t*, File_t*));
extern __MANGLE__ int		verify __PROTO__((Archive_t*, File_t*));
