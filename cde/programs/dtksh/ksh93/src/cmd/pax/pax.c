/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these libraries and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* $XConsortium: pax.c /main/3 1995/11/01 17:01:57 rswiston $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*         THIS IS PROPRIETARY SOURCE CODE LICENSED BY          *
*                          AT&T CORP.                          *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*                     All Rights Reserved                      *
*                                                              *
*           This software is licensed by AT&T Corp.            *
*       under the terms and conditions of the license in       *
*       http://www.research.att.com/orgs/ssr/book/reuse        *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                     gsf@research.att.com                     *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
static const char id[] = "\n@(#)pax (AT&T Bell Laboratories) 07/17/95\0\n";

#include "pax.h"
#include "options.h"

#include <tm.h>

char*			definput = "/dev/stdin";
char*			defoutput = "/dev/stdout";
char*			eomprompt = "Change to part %d and hit RETURN: ";

char			alar_header[ALAR_LABEL];
Hdr_binary_t		binary_header;
Hdr_portar_t		portar_header;
Hdr_tar_t		tar_header_block;
State_t			state;

Format_t		format[] =
{

{ALAR_NAME,	ALAR_REGULAR,	ALAR_SPECIAL,	ALAR_ALIGN,	ALAR_FLAGS},
{BINARY_NAME,	BINARY_REGULAR,	BINARY_SPECIAL,	BINARY_ALIGN,	BINARY_FLAGS},
{CPIO_NAME,	CPIO_REGULAR,	CPIO_SPECIAL,	CPIO_ALIGN,	CPIO_FLAGS},
{IBMAR_NAME,	IBMAR_REGULAR,	IBMAR_SPECIAL,	IBMAR_ALIGN,	IBMAR_FLAGS},
{TAR_NAME,	TAR_REGULAR,	TAR_SPECIAL,	TAR_ALIGN,	TAR_FLAGS},
{USTAR_NAME,	USTAR_REGULAR,	USTAR_SPECIAL,	USTAR_ALIGN,	USTAR_FLAGS},
{ASC_NAME,	ASC_REGULAR,	ASC_SPECIAL,	ASC_ALIGN,	ASC_FLAGS},
{ASCHK_NAME,	ASCHK_REGULAR,	ASCHK_SPECIAL,	ASCHK_ALIGN,	ASCHK_FLAGS},
{SAVESET_NAME,	SAVESET_REGULAR,SAVESET_SPECIAL,SAVESET_ALIGN,	SAVESET_FLAGS},
{PAX_NAME,	PAX_REGULAR,	PAX_SPECIAL,	PAX_ALIGN,	PAX_FLAGS},
{PORTAR_NAME,	PORTAR_REGULAR,	PORTAR_SPECIAL,	PORTAR_ALIGN,	PORTAR_FLAGS},
{RANDAR_NAME,	RANDAR_REGULAR,	RANDAR_SPECIAL,	RANDAR_ALIGN,	RANDAR_FLAGS},
{VDB_NAME,	VDB_REGULAR,	VDB_SPECIAL,	VDB_ALIGN,	VDB_FLAGS},

{COMPRESS_NAME, 0, COMPRESS_MAGIC, 0,0, COMPRESS_ALGORITHM, COMPRESS_UNDO},
{GZIP_NAME,     0, GZIP_MAGIC,     0,0,	GZIP_ALGORITHM,     GZIP_UNDO},

{DELTA_NAME,          0,0,0, OUT, DELTA_ALGORITHM},
{DELTA_88_NAME,       0,0,0, 0,   DELTA_88_ALGORITHM},
{DELTA_IGNORE_NAME},
{DELTA_PATCH_NAME},

{0}

};

Option_t		options[] =
{
{
	0,
},
{
	"append",
	'a',
	OPT_append,
	"append to end of archive",
},
{
	"atime",
	0,
	OPT_atime,
	"[=time] preserve access time",
	OPT_HEADER,
},
{
	"base",
	'z',
	OPT_base,
	"=path delta base archive name\n\
-  ignore base on input, compress on output",
},
{
	"blocksize",
	'b',
	OPT_blocksize,
	"[=size] output block size [format specific]",
},
{
	"blok",
	0,
	OPT_blok,
	"[=[io]] input/output BLOK format for tapes on file",
},
{
	"charset",
	0,
	OPT_charset,
	"=name header data character set name",
	OPT_HEADER,
},
{
	"chksum",
	0,
	OPT_chksum,
	0,
	OPT_READONLY,
},
{
	"clobber",
	'k',
	OPT_clobber,
	"overwrite output files [on]",
},
{
	"comment",
	0,
	OPT_comment,
	"=text header comment text",
	OPT_HEADER,
},
{
	"complete",
	0,
	OPT_complete,
	"complete archive must fit in one media part",
},
{
	"crossdevice",
	'X',
	OPT_crossdevice,
	"ok to cross device boundaries [on]",
},
{
	"ctime",
	0,
	OPT_ctime,
	"[=time] preserve change time",
	OPT_HEADER,
},
{
	"debug",
	'D',
	OPT_debug,
	"[=level] debug trace level",
},
{
	"delta",
	0,
	OPT_delta,
	0,
	OPT_READONLY,
},
{
	"descend",
	'd',
	OPT_descend,
	"directory names self and descendents [on]",
},
{
	"device",
	0,
	OPT_device,
	0,
	OPT_READONLY,
},
{
	"devmajor",
	0,
	OPT_devmajor,
	0,
	OPT_READONLY,
},
{
	"devminor",
	0,
	OPT_devminor,
	0,
	OPT_READONLY,
},
{
	"dots",
	0,
	OPT_dots,
	"drop a dot for each block transferred",
},
{
	"edit",
	's',
	OPT_edit,
	"=,old,new,[glsu] pathname substitution from old to new\n\
g  all old patterns\n\
l  convert new to lower case\n\
p  print edit result\n\
s  stop edits on path if this edit succeeds\n\
u  convert new to upper case",
},
{
	"eom",
	0,
	OPT_eom,
	"=prompt end of media prompt",
},
{
	"exact",
	'n',
	OPT_exact,
	"exit after each file arg matches exactly once",
},
{
	"extended.ignore",
	0,
	OPT_extended_ignore,
	"=pat ignore/omit extended header keywords matching pattern",
},
{
	"extended.path",
	0,
	OPT_extended_path,
	"=format extended header pathname [HEADER!!!]",
},
{
	"file",
	'f',
	OPT_file,
	"=path main archive file name",
},
{
	"filter",
	0,
	OPT_filter,
	"=command input/output file filter command",
},
{
	"format",
	'x',
	OPT_format,
	"=format output archive format [cpio]\n\
     ansi  ANSI standard label tape [tape only]\n\
      asc  s5r4 extended cpio character\n\
    aschk  s5r4 extended cpio character with checksum\n\
   binary  cpio binary with symlinks\n\
     cpio  cpio character with symlinks\n\
    ibmar  EBCDIC standard label tape [tape only]\n\
      pax  POSIX 1003.2b-1995 extended ustar\n\
 portarch  s5r2 portable object library [input only]\n\
 randarch  BSD ranlib object library [input only]\n\
      tar  tar with symlinks\n\
    ustar  POSIX 1003.1-1988 tar\n\
      vdb  virtual database\n\
vmsbackup  VMS backup savset [input tape only]\n\
---------  standard compression algorithms\n\
 compress  compress the output when done\n\
     gzip  gzip the output when done\n\
---------  delta algorithms\n\
    delta  delta 94\n\
  delta88  delta 88\n\
   ignore  ignore delta headers\n\
    patch  delta using standard archive formats",
},
{
	"gname",
	0,
	OPT_gname,
	"[=group] set group name",
	OPT_HEADER,
},
{
	"help",
	0,
	OPT_help,
	"print this information and exit",
},
{
	"ignore",
	0,
	OPT_ignore,
	"=pat ignore/omit all header keywords matching pattern",
},
{
	"ino",
	0,
	OPT_ino,
	0,
	OPT_READONLY,
},
{
	"invalid",
	0,
	OPT_invalid,
	"=str invalid path action\n\
   ignore  silently ignore\n\
   prompt  prompt for new name\n\
translate  translate and/or truncate\n\
     UTF8  convert to UTF8",
},
{
	"invert",
	0,
	OPT_invert,
	"invert pattern match sense -- use !(...) instead",
},
{
	"keepgoing",
	0,
	OPT_keepgoing,
	"attempt repair on read",
},
{
	"label",
	0,
	OPT_label,
	"=str append volume label",
},
{
	"label.insert",
	0,
	OPT_label_insert,
	"=str insert volume label",
},
{
	"link",
	0,
	OPT_link,
	"hard link files on output if possible",
},
{
	"linkdata",
	0,
	OPT_linkdata,
	"output data with each hard link",
},
{
	"linkop",
	0,
	OPT_linkop,
	0,
	OPT_READONLY,
},
{
	"linkpath",
	0,
	OPT_linkpath,
	"header symbolic link path name",
	OPT_HEADER,
},
{
	"listformat",
	0,
	OPT_listformat,
	"=format listing format",
},
{
	"listmacro",
	0,
	OPT_listmacro,
	"=name[=value] listformat macro definition",
},
{
	"logical",
	'L',
	OPT_logical,
	"follow symbolic links [on]",
},
{
	"magic",
	0,
	OPT_magic,
	0,
	OPT_READONLY,
},
{
	"mark",
	0,
	OPT_mark,
	0,
	OPT_READONLY,
},
{
	"maxblocks",
	0,
	OPT_maxblocks,
	"=blocks output media block limit",
},
{
	"metaphysical",
	'H',
	OPT_metaphysical,
	"follow top level directory symbolic links",
},
{
	"mkdir",
	0,
	OPT_mkdir,
	"create intermediate directories on output [on]",
},
{
	"mode",
	0,
	OPT_mode,
	0,
	OPT_READONLY,
},
{
	"mtime",
	0,
	OPT_mtime,
	"[=time] preserve file modify time [on]",
	OPT_HEADER,
},
{
	"name",
	0,
	OPT_name,
	"header file name",
	OPT_HEADER,
},
{
	"nlink",
	0,
	OPT_nlink,
	0,
	OPT_READONLY,
},
{
	"ordered",
	'O',
	OPT_ordered,
	"input files and base are ordered by name",
},
{
	"owner",
	0,
	OPT_owner,
	"[=uid] change output file owner to current user [uid]",
},
{
	"path",
	0,
	OPT_path,
	"header path name",
	OPT_HEADER,
},
{
	"physical",
	'P',
	OPT_physical,
	"don't follow symbolic links",
},
{
	"preserve",
	'p',
	OPT_preserve,
	"=[aemp] preserve file attributes\n\
a  preserve access time\n\
e  preserve everything permissible\n\
m  don't preserve modify time\n\
p  preserve owner",
},
{
	"read",
	'r',
	OPT_read,
	"read from archive",
},
{
	"record.charset",
	0,
	OPT_record_charset,
	"character set translation [format specific] [on]",
},
{
	"record.delimiter",
	0,
	OPT_record_delimiter,
	"[=c] vdb record delimiter, 0 if omitted [;]",
},
{
	"record.format",
	0,
	OPT_record_format,
	"=[DFSUV] labelled tape record format\n\
D  decimal variable\n\
F  fixed length\n\
S  spanned\n\
U  input block size\n\
B  binary variable",
},
{
	"record.header",
	0,
	OPT_record_header,
	"[=str] member header, 0 if omitted [format specific]",
},
{
	"record.line",
	0,
	OPT_record_line,
	"records are lines [format specific]",
},
{
	"record.match",
	0,
	OPT_record_match,
	"=pat select record formats that match patterns",
},
{
	"record.pad",
	0,
	OPT_record_pad,
	"pad records [format specific]",
},
{
	"record.size",
	0,
	OPT_record_size,
	"=size fixed length record size [format specific]",
},
{
	"record.trailer",
	0,
	OPT_record_trailer,
	"[=str] member trailer, 0 if omitted [format specific]",
},
{
	"sequence",
	0,
	OPT_sequence,
	0,
	OPT_READONLY,
},
{
	"size",
	0,
	OPT_size,
	0,
	OPT_READONLY,
},
{
	"summary",
	0,
	OPT_summary,
	"list summary information [on]",
},
{
	"symlink",
	0,
	OPT_symlink,
	"symlink files if possible",
},
{
	"tape",
	0,
	OPT_tape,
	"=[#][lmhcu][n][bv][s[#]][k[#]] tape unit and ops\n\
#	unit number [0-9]\n\
l	low density\n\
m	medium density\n\
h	high density\n\
c	compressed\n\
u	uncompressed\n\
n	don't rewind on close\n\
b	bsd behavior\n\
v	system V behavior\n\
s[#]	skip all [#] volumes\n\
k[#]	keep all [#] volumes after skip",
},
{
	"test",
	0,
	OPT_test,
	"=bits test mask [use at own risk]",
},
{
	"typeflag",
	0,
	OPT_typeflag,
	0,
	OPT_READONLY,
},
{
	"uname",
	0,
	OPT_uname,
	"[=user] header user name",
	OPT_HEADER,
},
{
	"unblocked",
	0,
	OPT_unblocked,
	"[=[io]] force unblocked input/output [format specific]",
},
{
	"update",
	'u',
	OPT_update,
	"only copy archive members that are newer",
},
{
	"verbose",
	'v',
	OPT_verbose,
	"long listing",
},
{
	"verify",
	'i',
	OPT_verify,
	"interactive verification and/or rename",
},
{
	"version",
	0,
	OPT_version,
	0,
	OPT_READONLY,
},
{
	"write",
	'w',
	OPT_write,
	"write to archive",
},
{
	"yes",
	0,
	OPT_yes,
	"yes/no query for files",
},
{
	"gid",
	0,
	OPT_gname,
	0,
	OPT_ALIAS,
},
{
	"linkname",
	0,
	OPT_linkpath,
	0,
	OPT_ALIAS,
},
{
	"uid",
	0,
	OPT_uname,
	0,
	OPT_ALIAS,
},
};

static int		signals[] =	/* signals caught by interrupt() */
{
	SIGHUP,
	SIGINT,
#if !DEBUG
	SIGQUIT,
#endif
	SIGALRM,
	SIGTERM,
};

static struct
{
	char*		arg0;
	Sfio_t*		ignore;
	Sfio_t*		ignore_extended;
	Map_t*		lastmap;
	Sfio_t*		listformat;
	char*		owner;
} opt;

/*
 * clean up dir info before exit
 */

static void
interrupt __PARAM__((int sig), (sig)) __OTORP__(int sig;){
	signal(sig, SIG_IGN);
	sigunblock(sig);
	switch (sig)
	{
	case SIGINT:
	case SIGQUIT:
		sfprintf(sfstderr, "\n");
		break;
	}
	state.interrupt = sig;
	finish(1);
}

/*
 * enter new substitute expression(s)
 */

static void
substitute __PARAM__((Map_t** lastmap, char* s), (lastmap, s)) __OTORP__(Map_t** lastmap; char* s;){
	Map_t*	mp;
	int	n;
	char*		p;

	for (;;)
	{
		while (isspace(*s)) s++;
		if (!(n = *s++)) break;
		p = s;
		while (*s && *s != n)
			if (*s++ == '\\' && !*s++)
				error(3, "`\\' cannot terminate lhs of substitution");
		if (*s != n)
			error(3, "missing `%c' delimiter for lhs of substitution", n);
		*s++ = 0;
		if (!(mp = newof(0, Map_t, 1, 0)))
			error(3, "no space [substitution]");
		mp->re = recomp(p, RE_EDSTYLE|RE_MATCH);
		mp->into = s;
		while (*s && *s != n)
			if (*s++ == '\\' && !*s++)
				error(3, "`\\' cannot terminate rhs of substitution");
		if (*s != n) error(3, "missing `%c' delimiter for rhs of substitution", n);
		*s++ = 0;
		for (;;)
		{
			switch (*s++)
			{
			case 0:
				s--;
				break;
			case 'g':
				mp->flags |= RE_ALL;
				continue;
			case 'l':
				mp->flags |= RE_LOWER;
				continue;
			case 'p':
				mp->flags |= RE_VERBOSE;
				continue;
			case 's':
				mp->flags |= RE_STOP;
				continue;
			case 'u':
				mp->flags |= RE_UPPER;
				continue;
			default:
				if (*(s - 1) == n) break;
				error(3, "extra character%s `%s' after substitution", *s ? "s" : "", s - 1);
				break;
			}
			break;
		}
		mp->into = strdup(mp->into);
		if (*lastmap) *lastmap = (*lastmap)->next = mp;
		else state.maps = *lastmap = mp;
	}
}

/*
 * help and exit
 */

#define OPT_WIDTH	22

static void
help __PARAM__((void), ()){
	char*		s;
	char*		e;
	Sfio_t*	sp;
	int			n;

	sp = sfstropen();
	sfprintf(sfstderr, "Usage: %s -o '[no]name[[:]=value] ...' [file ...]\n\n%*s  %s\n", error_info.id, OPT_WIDTH, "", id + 5);
	for (n = 0; n < elementsof(options); n++)
		if (s = options[n].description)
		{
			sfprintf(sp, "%s", options[n].name);
			if (*s == '=' || *s == '[' && *(s + 1) == '=')
			{
				e = s;
				while (*s && !isspace(*s++));
				sfprintf(sp, "%-.*s", s - e - 1, e);
			}
			sfprintf(sfstderr, "%*s  ", OPT_WIDTH, sfstruse(sp));
			if (options[n].flag) sfprintf(sfstderr, "(-%c) ", options[n].flag);
			while (e = strchr(s, '\n'))
			{
				sfprintf(sfstderr, "%-.*s%-*.*s", e - s + 1, s, OPT_WIDTH + 2, OPT_WIDTH + 2, "");
				s = e + 1;
			}
			sfprintf(sfstderr, "%s\n", s);
		}
	sfstrclose(sp);
	exit(0);
}

/*
 * called by stropt() to set options
 */

int
setoption __PARAM__((__V_* a, const __V_* p, int n, const char* v), (a, p, n, v)) __OTORP__(__V_* a; const __V_* p; int n; const char* v;){
	int		c;
	char*		e;
	char*		s;
	Archive_t*	ap;
	Option_t*	op;
	Value_t*	vp;

	if (!v) v = "";
	if (p)
	{
		op = (Option_t*)p;
		c = 1 + !(ap = (Archive_t*)a) + 2 * (n < 0);
		if (op->level > c)
			return(0);
		if (!ap || c != 4)
			op->level = c;
		if (ap) op->entry = ap->entry + 1;
		vp = (c >= 3) ? &op->temp : &op->perm;
		if (n && *v && (op->flags & (OPT_HEADER|OPT_READONLY)) == OPT_HEADER)
		{
			op->flags |= OPT_SET;
			c = strlen(v) + 1;
			if (c > vp->size)
			{
				c = roundof(c, 64);
				if (!(vp->string = newof(vp->string, char, c, 0)))
					error(3, "out of space [value]");
				vp->size = c;
			}
			strcpy(vp->string, v);
		}
		else vp = 0;
		message((-4, "option: %s%s%s%s", n ? "" : "no", op->name, (n < 0) ? ":=" : *v ? "=" : "", v));
		switch (op->index)
		{
		case OPT_append:
			state.append = n;
			break;
		case OPT_atime:
			state.acctime = n;
			if (vp)
			{
			settime:
				vp->number = strtoul(vp->string, &e, NiL);
				if (*e == '.')
					strtol(e + 1, &e, NiL);
				if (*e)
				{
					vp->number = tmdate(vp->string, &e, NiL);
					if (*e) error(2, "%s: invalid %s date string", vp->string, options[op->index].name);
				}
			}
			break;
		case OPT_base:
			ap = getarchive(state.operation);
			if (ap->delta)
				error(3, "base archive already specified");
			if (n)
			{
				initdelta(ap);
				if (!*v || streq(v, "-"))
				{
					if (!(state.operation & OUT))
					{
						ap->delta->format = DELTA_IGNORE;
						break;
					}
					v = "/dev/null";
				}
				ap->delta->base = initarchive(strdup(v), O_RDONLY);
			}
			break;
		case OPT_blocksize:
			if (n)
			{
				state.blocksize = strton(v, &e, NiL, BLOCKSIZE);
				if (*e) error(3, "%s: invalid block size", v);
				if (state.blocksize < MINBLOCK)
					error(3, "block size must be at least %d", MINBLOCK);
				if (state.blocksize & (BLOCKSIZE - 1))
					error(1, "block size should probably be a multiple of %d", BLOCKSIZE);
			}
			else state.blocksize = DEFBLOCKS * BLOCKSIZE;
			break;
		case OPT_blok:
			if (!*v) getarchive(IN)->io.blok = getarchive(OUT)->io.blok = n;
			else while (*v) switch (*v++)
			{
			case 'i':
				getarchive(IN)->io.blok = 1;
				break;
			case 'o':
				getarchive(OUT)->io.blok = 1;
				break;
			default:
				error(3, "%s: [io] expected", ((Option_t*)p)->name);
				break;
			}
			break;
		case OPT_clobber:
			state.clobber = n;
			break;
		case OPT_comment:
			state.header.comment = n ? strdup(v) : (char*)0;
			break;
		case OPT_complete:
			state.complete = n;
			break;
		case OPT_crossdevice:
			state.xdev = n;
			break;
		case OPT_ctime:
			if (vp) goto settime;
			break;
		case OPT_debug:
			if (n)
			{
				error_info.trace = -strton(v, &e, NiL, 0);
				if (*e) error(3, "%s: invalid block debug level", v);
			}
			else error_info.trace = 0;
			break;
		case OPT_descend:
			state.descend = n;
			break;
		case OPT_dots:
			state.drop = n;
			break;
		case OPT_edit:
			substitute(&opt.lastmap, (char*)v);
			break;
		case OPT_eom:
			eomprompt = n ? strdup(v) : (char*)0;
			break;
		case OPT_exact:
			state.exact = n;
			break;
		case OPT_extended_ignore:
			if (n && *v)
				sfprintf(opt.ignore_extended, "%s(%s)", sfstrtell(opt.ignore_extended) ? "|" : "", v);
			break;
		case OPT_extended_path:
			state.header.name = n ? strdup(v) : (char*)0;
			break;
		case OPT_file:
			ap = getarchive(state.operation);
			if (ap->name)
				error(3, "%s: %s: archive name already specified", v, ap->name);
			ap->name = strdup(v);
			break;
		case OPT_filter:
			state.filter = n ? (char**)(streq(v, "-") ? "" : strdup(v)) : (char**)0;
			break;
		case OPT_format:
			ap = getarchive(state.operation);
			if (!n) ap->format = -1;
			else if (s = strdup(v)) do
			{
				for (e = s;;)
				{
					switch (*e++)
					{
					case 0:
						e = 0;
						break;
					case ' ':
					case '\t':
					case '\n':
					case ':':
					case ',':
						*(e - 1) = 0;
						if (*s) break;
						s = e;
						continue;
					default:
						continue;
					}
					break;
				}
				if ((n = getformat(s)) >= DELTA)
				{
					initdelta(ap);
					switch (n)
					{
					case DELTA_IGNORE:
					case DELTA_PATCH:
						ap->delta->format = n;
						break;
					default:
						ap->delta->version = n;
						break;
					}
				}
				else if (n >= COMPRESS)
					ap->compress = n;
				else if ((ap->format = n) < 0)
				{
					Sfio_t*	sp;

					if (!pathpath(tar_block, "lib/pax", opt.arg0, PATH_EXECUTE) || sfsprintf(alar_header, sizeof(alar_header) - 1, "%s/%s.fmt", tar_block, s) <= 0 || !(sp = sfopen(NiL, alar_header, "r")))
						error(3, "%s: unknown archive format", s);
					while (e = sfgetr(sp, '\n', 1))
						if (*e != '#')
							stropt(e, state.options, 0, setoption, NiL);
					sfclose(sp);
				}
			} while (s = e);
			break;
		case OPT_help:
			if (n) help();
			break;
		case OPT_ignore:
			if (n && *v)
				sfprintf(opt.ignore, "%s(%s)", sfstrtell(opt.ignore) ? "|" : "", v);
			break;
		case OPT_invalid:
			if (!n || !*v || streq(v, "ignore") || streq(v, "bypass"))
				state.header.invalid = INVALID_ignore;
			else if (streq(v, "prompt") || streq(v, "rename"))
				state.header.invalid = INVALID_prompt;
			else if (streq(v, "translate") || streq(v, "write"))
				state.header.invalid = INVALID_translate;
			else if (streq(v, "UTF8"))
				state.header.invalid = INVALID_UTF8;
			break;
		case OPT_invert:
			state.matchsense = !n;
			break;
		case OPT_keepgoing:
			state.keepgoing = n;
			break;
		case OPT_label:
			if (*state.id.volume)
			{
				sfsprintf(tar_block, sizeof(tar_block), "%s %s", state.id.volume, v);
				v = (const char*)tar_block;
			}
			strncpy(state.id.volume, v, sizeof(state.id.volume) - 2);
			break;
		case OPT_label_insert:
			if (*state.id.volume)
			{
				sfsprintf(tar_block, sizeof(tar_block), "%s %s", v, state.id.volume);
				v = (const char*)tar_block;
			}
			strncpy(state.id.volume, v, sizeof(state.id.volume) - 2);
			break;
		case OPT_link:
			if (n) state.linkf = link;
			else state.linkf = 0;
			break;
		case OPT_linkdata:
			state.header.linkdata = n;
			break;
		case OPT_listformat:
			if (n && *v)
				sfputr(opt.listformat, v, ' ');
			break;
		case OPT_listmacro:
			if (n && *v)
			{
				if (s = strchr(v, '='))
					*s++ = 0;
				if (!(op = (Option_t*)hashget(state.options, v)))
				{
					if (!s) break;
					if (!(op = newof(0, Option_t, 1, 0)))
						error(3, "out of space [option]");
					op->name = hashput(state.options, 0, op);
				}
				if (s)
				{
					op->macro = strdup(s);
					*(s - 1) = 0;
				}
				else op->macro = 0;
			}
			break;
		case OPT_logical:
			if (n) state.ftwflags &= ~FTW_PHYSICAL;
			else state.ftwflags |= FTW_PHYSICAL;
			break;
		case OPT_maxblocks:
			if (n)
			{
				state.maxout = strton(v, &e, NiL, 0);
				if (*e) error(3, "%s: invalid block count", v);
			}
			else state.maxout = 0;
			break;
		case OPT_metaphysical:
			if (n) state.ftwflags |= FTW_META|FTW_PHYSICAL;
			else state.ftwflags &= ~(FTW_META|FTW_PHYSICAL);
			break;
		case OPT_mkdir:
			state.intermediate = n;
			break;
		case OPT_mtime:
			state.modtime = n;
			if (vp) goto settime;
			break;
		case OPT_ordered:
			state.ordered = n;
			break;
		case OPT_owner:
			if (!(state.owner = n)) opt.owner = 0;
			else if (*v) opt.owner = strdup(v);
			break;
		case OPT_physical:
			if (n)
			{
				state.ftwflags &= ~FTW_META;
				state.ftwflags |= FTW_PHYSICAL;
			}
			else state.ftwflags &= ~FTW_PHYSICAL;
			break;
		case OPT_preserve:
			while (c = *v++) switch (c)
			{
			case 'a':
				setoption(NiL, &options[OPT_atime], 1, NiL);
				break;
			case 'e':
				setoption(NiL, &options[OPT_atime], 1, NiL);
				setoption(NiL, &options[OPT_mtime], 1, NiL);
				setoption(NiL, &options[OPT_owner], 1, NiL);
				break;
			case 'm':
				setoption(NiL, &options[OPT_mtime], 0, NiL);
				break;
			case 'p':
				setoption(NiL, &options[OPT_owner], 1, NiL);
				break;
			default:
				error(1, "%c: unknown preserve flag", c);
				break;
			}
			break;
		case OPT_read:
			if (n) state.operation |= IN;
			else state.operation &= ~IN;
			break;
		case OPT_record_charset:
			state.record.charset = n;
			break;
		case OPT_record_delimiter:
			if (!n) state.record.delimiter = 0;
			else if (!*v) state.record.delimiter = VDB_DELIMITER;
			else state.record.delimiter = *v;
			break;
		case OPT_record_format:
			state.record.format = n ? *v : 0;
			break;
		case OPT_record_header:
			if (!n)
			{
				state.record.header = 0;
				state.record.headerlen = 0;
			}
			else if (!(state.record.headerlen = stresc(state.record.header = strdup(v))))
				state.record.headerlen = 1;
			break;
		case OPT_record_line:
			state.record.line = n;
			break;
		case OPT_record_match:
			state.record.pattern = n ? strdup(v) : (char*)0;
			break;
		case OPT_record_pad:
			state.record.pad = n;
			break;
		case OPT_record_size:
			state.record.size = strton(v, &e, NiL, 0);
			if (*e) error(3, "%s: invalid record size", v);
			break;
		case OPT_record_trailer:
			if (!n)
			{
				state.record.trailer = 0;
				state.record.trailerlen = 0;
			}
			else if (!(state.record.trailerlen = stresc(state.record.trailer = strdup(v))))
				state.record.trailerlen = 1;
			break;
		case OPT_summary:
			state.summary = n;
			break;
		case OPT_symlink:
			if (n) state.linkf = pathsetlink;
			else state.linkf = 0;
			break;
		case OPT_tape:
			ap = getarchive(state.operation);
			if (ap->name)
				error(3, "%s: %s: archive name already specified", v, ap->name);
			s = strtape(v, &e);
			if (*s) ap->name = s;
			for (;;)
			{
				switch (*e++)
				{
				case 'k':
					if (!(n = strtol(e, &e, 0))) n = -1;
					ap->io.keep = n;
					ap->io.mode = O_RDWR;
					continue;
				case 's':
					if (!(n = strtol(e, &e, 0))) n = -1;
					ap->io.skip = n;
					ap->io.mode = O_RDWR;
					continue;
				}
				e--;
				break;
			}
			if (*e) error(3, "%s: invalid tape unit specification [%s]", v, e);
			break;
		case OPT_test:
			if (n)
			{
				state.test |= strton(v, &e, NiL, 0);
				if (*e) error(3, "%s: invalid test mask", v);
			}
			else state.test = 0;
			break;
		case OPT_unblocked:
			if (!*v) getarchive(IN)->io.unblocked = getarchive(OUT)->io.unblocked = n;
			else while (*v) switch (*v++)
			{
			case 'i':
				getarchive(IN)->io.unblocked = 1;
				break;
			case 'o':
				getarchive(OUT)->io.unblocked = 1;
				break;
			default:
				error(3, "%s: [io] expected", ((Option_t*)p)->name);
				break;
			}
			break;
		case OPT_update:
			state.update = n;
			break;
		case OPT_verbose:
			state.verbose = n;
			break;
		case OPT_verify:
			state.verify = n;
			break;
		case OPT_write:
			if (n) state.operation |= OUT;
			else state.operation &= ~OUT;
			break;
		case OPT_yes:
			state.verify = state.yesno = n;
			break;
		}
	}
	else if (a && !strmatch(v, "+([0-9])"))
	{
		/*
		 * NOTE: number options ignored so extended headers
		 *	 can be passed as a single unit to stropt()
		 */

		error(2, "%s: unknown option", v);
		help();
	}
	return(0);
}

/*
 * mark ignored header keywords
 */

static void
ignore __PARAM__((void), ()){
	Option_t*	op;
	Hash_position_t*	pos;
	char*			all;
	char*			ext;
	int			lev;

	all = sfstrtell(opt.ignore) ? sfstruse(opt.ignore) : (char*)0;
	ext = sfstrtell(opt.ignore_extended) ? sfstruse(opt.ignore_extended) : (char*)0;
	if ((all || ext) && (pos = hashscan(state.options, 0)))
	{
		while (hashnext(pos))
			if (all && strmatch(pos->bucket->name, all) && (lev = 6) || ext && strmatch(pos->bucket->name, ext) && (lev = 5))
			{
				op = (Option_t*)pos->bucket->value;
				if (!(op->flags & OPT_READONLY))
					op->level = lev;
			}
		hashdone(pos);
	}
	sfstrclose(opt.ignore);
	sfstrclose(opt.ignore_extended);
}

int
main __PARAM__((int argc, char** argv), (argc, argv)) __OTORP__(int argc; char** argv;){
	int		i;
	char*		s;
	Archive_t*	ap;
	char*			p;
	Hash_position_t*	pos;
	Option_t*		op;
	int			n;
	int			convert = 0;
	struct stat		st;

	setlocale(LC_ALL, "");
	error_info.id = "pax";
	state.gid = getegid();
	state.uid = geteuid();
	umask(state.modemask = umask(0));
	state.ftwflags = ftwflags()|FTW_DOT;
	state.buffersize = DEFBUFFER * DEFBLOCKS;
	state.clobber = 1;
	state.descend = RESETABLE;
	state.header.name = "HEADER!!!";
	if (!(opt.ignore = sfstropen()) || !(opt.ignore_extended = sfstropen()))
		error(3, "out of space [ignore]");
	state.intermediate = 1;
	if (!(opt.listformat = sfstropen()))
		error(3, "out of space [listformat]");
	state.matchsense = 1;
	state.modtime = 1;
	if (!(state.options = hashalloc(NiL, HASH_name, "options", 0)))
		error(3, "out of space [options]");
	for (i = 1; i < elementsof(options); i++)
		hashput(state.options, options[i].name, &options[options[i].index]);
	hashset(state.options, HASH_ALLOCATE);
	state.record.charset = 1;
	state.record.line = 1;
	state.summary = 1;
	state.tmp.file = pathtemp(NiL, NiL, error_info.id);
	opt.arg0 = argv[0];
	while (i = optget(argv, "af:[archive]no:[[no]name[[:]=value]]rs:[/old/new/[pg]]vwx:[format]z:[base]?b:[blocking]cdiklp:[amop]HLXt:[tape]uD#[debug]OPT#[test] [<file-list | <archive] [file ... [directory]] | [pattern ...]")) switch (i)
	{

	/* basic options */

	case 'a':
		setoption(NiL, &options[OPT_append], 1, NiL);
		break;
	case 'f':
		setoption(NiL, &options[OPT_file], 1, opt_info.arg);
		break;
	case 'n':
		setoption(NiL, &options[OPT_exact], 1, NiL);
		break;
	case 'o':
		stropt(opt_info.arg, state.options, 0, setoption, NiL);
		break;
	case 'r':
		setoption(NiL, &options[OPT_read], 1, NiL);
		break;
	case 's':
		setoption(NiL, &options[OPT_edit], 1, opt_info.arg);
		break;
	case 'v':
		setoption(NiL, &options[OPT_verbose], 1, NiL);
		break;
	case 'w':
		setoption(NiL, &options[OPT_write], 1, NiL);
		break;
	case 'x':
		setoption(NiL, &options[OPT_format], 1, opt_info.arg);
		break;
	case 'z':
		setoption(NiL, &options[OPT_base], 1, opt_info.arg);
		break;

	/* NOTE: the rest are best set by -o name */

	/* posix options */

	case 'b':
		setoption(NiL, &options[OPT_blocksize], 1, opt_info.arg);
		break;
	case 'c':
		setoption(NiL, &options[OPT_invert], 1, NiL);
		break;
	case 'd':
		setoption(NiL, &options[OPT_descend], 0, NiL);
		break;
	case 'i':
		setoption(NiL, &options[OPT_verify], 1, NiL);
		break;
	case 'k':
		setoption(NiL, &options[OPT_clobber], 0, NiL);
		break;
	case 'l':
		setoption(NiL, &options[OPT_link], 1, NiL);
		break;
	case 'p':
		setoption(NiL, &options[OPT_preserve], 1, opt_info.arg);
		break;
	case 'H':
		setoption(NiL, &options[OPT_metaphysical], 1, NiL);
		break;
	case 'L':
		setoption(NiL, &options[OPT_logical], 1, NiL);
		break;
	case 'X':
		setoption(NiL, &options[OPT_crossdevice], 1, NiL);
		break;

	/* extended options */

	case 't':
		setoption(NiL, &options[OPT_tape], 1, opt_info.arg);
		break;
	case 'u':
		setoption(NiL, &options[OPT_update], 1, NiL);
		break;
	case 'D':
		setoption(NiL, &options[OPT_debug], 1, opt_info.arg);
		break;
	case 'O':
		setoption(NiL, &options[OPT_ordered], 1, NiL);
		break;
	case 'P':
		setoption(NiL, &options[OPT_physical], 1, NiL);
		break;
	case 'T':
		setoption(NiL, &options[OPT_test], 1, opt_info.arg);
		break;

	/* option errors */

	case '?':
		error(ERROR_USAGE|4, opt_info.arg);
		break;
	case ':':
		error(2, opt_info.arg);
		break;

	}
	argv += opt_info.index;
	argc -= opt_info.index;
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	if (!state.operation)
	{
		state.operation = IN;
		state.list = 1;
	}
	if (sfstrtell(opt.listformat))
	{
		sfstrrel(opt.listformat, -1);
		sfputc(opt.listformat, '\n');
	}
	else sfputr(opt.listformat, (state.list && state.verbose) ? "%(mode)s %2(nlink)d %-8(uname)s %-8(gname)s%8(device:case::%(size)lu:*:%(device)s)s %(mtime)s %(delta:case:?*:%(delta)s )s%(path)s%(linkop:case:?*: %(linkop)s %(linkpath)s)s" : "%(delta:case:?*:%(delta)s )s%(path)s%(linkop:case:?*: %(linkop)s %(linkpath)s)", '\n');
	if (!(state.listformat = strdup(sfstruse(opt.listformat))))
		error(3, "out of space [listformat]");
	sfstrclose(opt.listformat);
	ignore();
	if (s = (char*)state.filter)
	{
		if (*s)
		{
			p = s;
			n = 3;
			while (i = *s++)
				if (isspace(i))
				{
					n++;
					while (isspace(*s)) s++;
				}
			if (!(state.filter = newof(0, char*, n, 0)))
				error(3, "no space [filter]");
			s = p;
			state.filter[0] = s;
			if (n > 3)
			{
				n = 1;
				while (i = *s++)
					if (isspace(i))
					{
						*(s - 1) = 0;
						while (isspace(*s)) s++;
						if (*s) state.filter[n++] = s;
					}
			}
			else n = 1;
			state.filterarg = state.filter + n;
		}
		else state.filter = 0;
	}
	state.statf = (state.ftwflags & FTW_PHYSICAL) ? lstat : pathstat;

	/*
	 * determine the buffer sizes
	 */

	switch (state.operation)
	{
	case IN|OUT:
		if (!state.in)
			break;
		/*FALLTHROUGH*/
	case IN:
	case OUT:
		getarchive(state.operation);
		break;
	}
	if (ap = state.out)
	{
		if (ap->format < 0) ap->format = OUT_DEFAULT;
		else if (state.operation == (IN|OUT)) convert = 1;
		if (state.operation == OUT)
		{
			if (state.files)
				state.ftwflags |= FTW_POST;
			if (state.update)
				state.append = 1;
		}
		if (state.append)
			ap->io.mode = O_CREAT|O_RDWR;
		ap->io.fd = 1;
		if (!ap->name || streq(ap->name, "-"))
			ap->name = defoutput;
		else
		{
			close(1);
			if (open(ap->name, ap->io.mode, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) != 1)
				error(ERROR_SYSTEM|3, "%s: cannot write", ap->name);
		}
		if (!state.blocksize)
		{
			if (fstat(ap->io.fd, &st))
				error(ERROR_SYSTEM|3, "%s: cannot stat", ap->name);
			st.st_mode = modex(st.st_mode);
			if (state.test & 040) st.st_mode = X_IFCHR;
			if (X_ITYPE(st.st_mode) == X_IFREG)
			{
				state.blocksize = format[ap->format].regular;
				ap->io.unblocked = 1;
			}
			else state.blocksize = format[ap->format].special;
			state.buffersize = state.blocksize *= BLOCKSIZE;
		}
		switch (ap->format)
		{
		case ALAR:
		case IBMAR:
			if (!state.record.format)
				state.record.format = ALAR_RECFORMAT;
			if (state.record.size <= 0) switch (state.record.format)
			{
			case 'D':
			case 'U':
				state.record.size = state.blocksize;
				break;
			case 'F':
				state.record.size = ALAR_RECSIZE;
				break;
			case 'S':
			case 'V':
				state.record.size = 0;
				break;
			default:
				error(3, "%s %c record format not supported on output", format[ap->format].name, state.record.format);
			}
			if (state.blocksize < state.record.size)
				error(3, "block size (%d) must be >= record size (%d)", state.blocksize, state.record.size);
			if (state.record.size && (state.blocksize / state.record.size) * state.record.size != state.blocksize)
				error(1, "block size should be a multiple of record size");
			break;
		default:
			if (state.record.format || state.record.size)
				error(1, "record format and size ignored for %s format", format[ap->format].name);
			break;
		}
	}
	else
	{
		if (state.blocksize) state.buffersize = state.blocksize;
		else state.blocksize = DEFBLOCKS * BLOCKSIZE;
		if (state.record.size)
			error(1, "record size automatically determined on archive read");
	}
	if (state.buffersize < state.blocksize)
		state.buffersize = state.blocksize;
	state.tmp.buffersize = state.buffersize;
	if (!(state.tmp.buffer = newof(0, char, state.tmp.buffersize, 0)))
		error(3, "out of space [tmp buffer]");
	message((-1, "blocksize=%d buffersize=%d recordsize=%d", state.blocksize, state.buffersize, state.record.size));

	/*
	 * initialize the main io
	 */

	switch (state.operation)
	{
	case IN:
	case OUT:
		getarchive(state.operation);
		break;
	}
	if (ap = state.in)
	{
		binit(ap);
		if (state.append)
		{
			error(1, "append ignored for archive read");
			state.append = 0;
		}
		if (!ap->name || streq(ap->name, "-"))
			ap->name = definput;
		else
		{
			close(0);
			if (open(ap->name, ap->io.mode))
				error(ERROR_SYSTEM|3, "%s: cannot read", ap->name);
		}
	}
	if (ap = state.out)
	{
		if (ap->format < 0) ap->format = OUT_DEFAULT;
		binit(ap);
		if (ap->compress)
		{
			Proc_t*	proc;
			List_t*	p;
			char*	cmd[3];

			cmd[0] = format[ap->compress].name;
			cmd[1] = format[ap->compress].algorithm;
			cmd[2] = 0;
			if (!(proc = procopen(*cmd, cmd, NiL, NiL, PROC_WRITE)))
				error(3, "%s: cannot execute %s filter", ap->name, format[ap->compress].name);
			n = proc->wfd;
			proc->wfd = 1;
			close(1);
			if (dup(n) != 1)
				error(3, "%s: cannot redirect %s filter output", ap->name, format[ap->compress].name);
			close(n);
			if (!(p = newof(0, List_t, 1, 0)))
				error(3, "out of space [state.proc]");
			p->item = (__V_*)proc;
			p->next = state.proc;
			state.proc = p;
		}
	}
	if (!(state.linktab = hashalloc(NiL, HASH_set, HASH_ALLOCATE, HASH_namesize, sizeof(Fileid_t), HASH_name, "links", 0)))
		error(3, "cannot allocate hard link table");
	if ((state.operation & IN) && !state.list && !(state.restore = hashalloc(NiL, HASH_set, HASH_ALLOCATE, HASH_name, "restore", 0)))
		error(3, "cannot allocate directory table");
	if (state.modtime)
		state.modemask = 0;
	if (state.owner)
	{
		if (state.operation & IN)
		{
			state.modemask = 0;
			if (opt.owner)
			{
				if ((state.setuid = struid(opt.owner)) < 0 || (state.setgid = strgid(opt.owner)) < 0)
					error(3, "%s: invalid user name", opt.owner);
				state.flags |= SETIDS;
			}
		}
		else error(1, "ownership assignment ignored on archive write");
	}
	if (state.verify)
		interactive();
	state.modemask = ~state.modemask & (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO);
#if DEBUG
	if ((state.test & 010) && (pos = hashscan(state.options, 0)))
	{
		while (hashnext(pos))
		{
			op = (Option_t*)pos->bucket->value;
			if (op->name == pos->bucket->name)
				sfprintf(sfstderr, "%-16s %c %2d %d perm=%ld:%s temp=%ld:%s%s%s\n", op->name, op->flag ? op->flag : '-', op->index, op->level, op->perm.number, op->perm.string, op->temp.number, op->temp.string, (op->flags & OPT_HEADER) ? " HEADER" : "", (op->flags & OPT_READONLY) ? " READONLY" : "");
		}
		hashdone(pos);
	}
#endif
	for (i = 0; i < elementsof(signals); i++)
		if (signal(signals[i], interrupt) == SIG_IGN)
			signal(signals[i], SIG_IGN);
	switch (state.operation)
	{
	case IN:
		if (*argv)
		{
			state.patterns = initmatch(argv);
			if (state.exact) state.matchsense = 1;
		}
		else if (state.exact)
			error(3, "file arguments expected");
		getcwd(state.pwd, PATH_MAX);
		state.pwdlen = strlen(state.pwd);
		state.pwd[state.pwdlen++] = '/';
		copyin(state.in);
		if (state.exact)
		{
			argv = state.patterns;
			while (s = *argv++)
				if (*s) error(2, "%s: %s: file not found in archive", state.in->name, s);
		}
		break;

	case OUT:
		if (*argv)
			state.files = argv;
		if (!state.maxout && state.complete)
			error(3, "maximum block count required");
		copy(state.out, copyout);
		break;

	case (IN|OUT):
		if (convert || state.in || state.out)
		{
			if (*argv)
				state.patterns = initmatch(argv);
			deltapass(getarchive(IN), getarchive(OUT));
		}
		else
		{
			if (--argc < 0)
			{
				error(2, "destination directory required for pass mode");
				error(ERROR_USAGE|4, optusage(NiL));
			}
			state.destination = argv[argc];
			argv[argc] = 0;
			if (*argv)
				state.files = argv;
			if (state.blocksize)
				error(1, "blocking ignored in pass mode");
			if (state.record.size)
				error(1, "record size ignored in pass mode");

			/*
			 * initialize destination dir
			 */

			pathcanon(state.destination, 0);
			if (stat(state.destination, &st) || !S_ISDIR(st.st_mode))
				error(3, "%s: destination must be a directory", state.destination);
			state.dev = st.st_dev;
			strcpy(state.pwd, state.destination);
			state.pwdlen = strlen(state.pwd);
			state.pwd[state.pwdlen++] = '/';
			getarchive(OUT)->pass = 1;
			copy(NiL, copyinout);
		}
		break;
	}
	finish(0);
}

/*
 * print number of blocks actually copied and exit
 */

void
finish __PARAM__((int code), (code)) __OTORP__(int code;){
	Archive_t*	ap;
	char*		x1 = &state.tmp.buffer[0];
	char*		x2 = &state.tmp.buffer[state.buffersize / 2];
	unsigned long	n;

	while (state.proc)
	{
		procclose((Proc_t*)state.proc->item);
		state.proc = state.proc->next;
	}
	remove(state.tmp.file);
	if (state.restore)
		hashwalk(state.restore, 0, restore, NiL);
	sfsync(sfstdout);
	if (state.dropcount)
	{
		sfprintf(sfstderr, "\n");
		sfsync(sfstderr);
	}
	if (state.summary)
	{
		ap = getarchive(state.operation);
		n = ap->io.count + ap->io.offset;
		if (ap->entries)
		{
			if (ap->volume > 1) sfsprintf(x1, state.tmp.buffersize / 2, ", %d volumes", ap->volume);
			else *x1 = 0;
			if (ap->volume > 0 && ap->part > ap->volume) sfsprintf(x2, state.tmp.buffersize / 2, ", %d parts", ap->part - ap->volume + 1);
			else *x2 = 0;
			n = (n + BLOCKSIZE - 1) / BLOCKSIZE;
			if (state.verbose) sfprintf(sfstderr, "%d file%s, %ld block%s%s%s\n", ap->selected, ap->selected == 1 ? "" : "s", n, n == 1 ? "" : "s", x1, x2);
			else sfprintf(sfstderr, "%ld block%s%s%s\n", n, n == 1 ? "" : "s", x1, x2);
		}
	}
	sfsync(sfstderr);
	if (state.interrupt)
	{
		signal(state.interrupt, SIG_DFL);
		kill(getpid(), state.interrupt);
		pause();
	}
	exit(code ? code : error_info.errors != 0);
}
