/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these libraries and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* $XConsortium: typeset.c /main/3 1995/11/01 16:30:25 rswiston $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*        THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF        *
*                    AT&T BELL LABORATORIES                    *
*         AND IS NOT TO BE DISCLOSED OR USED EXCEPT IN         *
*            ACCORDANCE WITH APPLICABLE AGREEMENTS             *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*              Unpublished & Not for Publication               *
*                     All Rights Reserved                      *
*                                                              *
*       The copyright notice above does not evidence any       *
*      actual or intended publication of such source code      *
*                                                              *
*               This software was created by the               *
*           Advanced Software Technology Department            *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                    {research,attmail}!dgk                    *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include	"defs.h"
#include	<error.h>
#include	"path.h"
#include	"name.h"
#include	"history.h"
#include	"builtins.h"
#include	"variables.h"

/* use these prototyped because dlhdr.h may be wrong */
extern __MANGLE__ __V_	*dlopen __PROTO__((const char*,int));
extern __MANGLE__ __V_	*dlsym __PROTO__((__V_*, const char*));
extern __MANGLE__ char	*dlerror __PROTO__((void));
#define DL_MODE	1

static int	print_namval __PROTO__((Sfio_t*, Namval_t*, int));
static void	print_attribute __PROTO__((Namval_t*));
static void	print_all __PROTO__((Sfio_t*, Hashtab_t*));
static void	print_scan __PROTO__((Sfio_t*, int, Hashtab_t*, int));
static int	b_unall __PROTO__((int, char**, Hashtab_t*));
static int	b_common __PROTO__((char**, int, Hashtab_t*));
static void	pushname __PROTO__((Namval_t*));
static void	unref __PROTO__((Namval_t*));
static char	**argnam;
static int	argnum;
static int 	aflag;
static int	scanmask;
static Hashtab_t *scanroot;
static Sfio_t	*outfile;
static void(*nullscan) __PROTO__((Namval_t*));
static char	*prefix;

static char *get_tree __PROTO__((Namval_t*, Namfun_t *));
static void put_tree __PROTO__((Namval_t*, const char*, int,Namfun_t*));

static const Namdisc_t treedisc =
{
	0,
	put_tree,
	get_tree
};


/*
 * The following few builtins are provided to set,print,
 * and test attributes and variables for shell variables,
 * aliases, and functions.
 * In addition, typeset -f can be used to test whether a
 * function has been defined or to list all defined functions
 * Note readonly is same as typeset -r.
 * Note export is same as typeset -x.
 */

int    b_read_export __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	int flag;
	char *command = argv[0];
	NOT_USED(argc);
	NOT_USED(extra);
	aflag = '-';
	argnum = 0;
	prefix = 0;
	while((flag = optget(argv,sh_optexport))) switch(flag)
	{
		case 'p':
			prefix = command;
			break;
		case ':':
			error(2, opt_arg);
			break;
		case '?':
			error(ERROR_usage(0), opt_arg);
			return(2);
	}
	if(error_info.errors)
		error(ERROR_usage(2),optusage(NIL(char*)));
	argv += (opt_index-1);
	if(*command=='r')
		flag = (NV_ASSIGN|NV_RDONLY|NV_VARNAME);
	else
		flag = (NV_ASSIGN|NV_EXPORT|NV_IDENT);
	if(*argv)
		return(b_common(argv,flag,sh.var_tree));
	print_scan(sfstdout,flag,sh.var_tree,aflag=='+');
	return(0);
}


int    b_alias __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	unsigned flag = NV_ARRAY|NV_NOSCOPE|NV_ASSIGN;
	Hashtab_t *troot = sh.alias_tree;
	int n;
	NOT_USED(argc);
	NOT_USED(extra);
	prefix=0;
	if(*argv[0]=='h')
		flag = NV_TAGGED;
	if(argv[1])
	{
		opt_char = 0;
		opt_index = 1;
		*opt_option = 0;
		argnum = 0;
		aflag = *argv[1];
		while((n = optget(argv,sh_optalias))) switch(n)
		{
		    case 'p':
			prefix = argv[0];
			break;
		    case 't':
			flag |= NV_TAGGED;
			break;
		    case 'x':
			flag |= NV_EXPORT;
			break;
		    case ':':
			error(2, opt_arg);
			break;
		    case '?':
			error(ERROR_usage(0), opt_arg);
			return(2);
		}
		if(error_info.errors)
			error(ERROR_usage(2),optusage(NIL(char*)));
		argv += (opt_index-1);
		if(flag&NV_TAGGED)
		{
			if(argv[1] && strcmp(argv[1],"-r")==0)
			{
				/* hack to handle hash -r */
				nv_putval(PATHNOD,nv_getval(PATHNOD),NV_RDONLY);
				return(0);
			}
			troot = sh.track_tree;
		}
	}
	return(b_common(argv,flag,troot));
}


int    b_typeset __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	int flag = NV_VARNAME|NV_ASSIGN;
	int n;
	Hashtab_t *troot = sh.var_tree;
	int isfloat = 0;
	NOT_USED(argc);
	NOT_USED(extra);
	aflag = argnum  = 0;
	prefix = 0;
	while((n = optget(argv,sh_opttypeset)))
	{
		switch(n)
		{
			case 'A':
				flag |= NV_ARRAY;
				break;
			case 'E':
				/* The following is for ksh88 compatibility */
				if(opt_char && !strchr(argv[opt_index],'E'))
				{
					argnum = (int)opt_num;
					break;
				}
			case 'F':
				if(!opt_arg || (argnum = opt_num) <0)
					argnum = 10;
				isfloat = 1;
				if(n=='E')
					flag |= NV_EXPNOTE;
				break;
			case 'n':
				flag &= ~NV_VARNAME;
				flag |= (NV_REF|NV_IDENT);
				break;
			case 'H':
				flag |= NV_HOST;
				break;
#ifdef SHOPT_OO
			case 'C':
				prefix = opt_arg;
				flag |= NV_IMPORT;
				break;
#endif /* SHOPT_OO */
			case 'L':
				if(argnum==0)
					argnum = (int)opt_num;
				if(argnum < 0)
					error(ERROR_exit(1), e_badfield, argnum);
				flag |= NV_LJUST;
				break;
			case 'Z':
				flag |= NV_ZFILL;
				/* FALL THRU*/
			case 'R':
				if(argnum==0)
					argnum = (int)opt_num;
				if(argnum < 0)
					error(ERROR_exit(1), e_badfield, argnum);
				flag |= NV_RJUST;
				break;
			case 'f':
				flag &= ~(NV_VARNAME|NV_ASSIGN);
				troot = sh.fun_tree;
				break;
			case 'i':
				if(!opt_arg || (argnum = opt_num) <0)
					argnum = 1;
				flag |= NV_INTEGER;
				break;
			case 'l':
				flag |= NV_UTOL;
				break;
			case 'p':
				prefix = argv[0];
				continue;
			case 'r':
				flag |= NV_RDONLY;
				break;
			case 't':
				flag |= NV_TAGGED;
				break;
			case 'u':
				flag |= NV_LTOU;
				break;
			case 'x':
				flag &= ~NV_VARNAME;
				flag |= (NV_EXPORT|NV_IDENT);
				break;
			case ':':
				error(2, opt_arg);
				break;
			case '?':
				error(ERROR_usage(0), opt_arg);
				return(2);
		}
		if(aflag==0)
			aflag = *opt_option;
	}
	argv += opt_index;
	/* handle argument of + and - specially */
	if(*argv && argv[0][1]==0 && (*argv[0]=='+' || *argv[0]=='-'))
		aflag = *argv[0];
	else
		argv--;
	if((flag&NV_INTEGER) && (flag&(NV_LJUST|NV_RJUST|NV_ZFILL)))
		error_info.errors++;
	if(troot==sh.fun_tree && ((isfloat || flag&~(NV_FUNCT|NV_TAGGED|NV_EXPORT|NV_LTOU))))
		error_info.errors++;
	if(error_info.errors)
		error(ERROR_usage(2),optusage(NIL(char*)));
	if(isfloat)
		flag |= NV_INTEGER|NV_DOUBLE;
	if(sh.fn_depth)
		flag |= NV_NOSCOPE;
	return(b_common(argv,flag,troot));
}

static int     b_common __PARAM__((char **argv,int flag,Hashtab_t *troot), (argv, flag, troot)) __OTORP__(char **argv;int flag;Hashtab_t *troot;){
	char *name;
	int nvflags=(flag&(NV_ARRAY|NV_NOSCOPE|NV_VARNAME|NV_IDENT|NV_ASSIGN));
	int r=0, ref=0;
#ifdef SHOPT_OO
	char *base=0;
	if(flag&NV_IMPORT)
	{
		if(!argv[1])
			error(ERROR_exit(1),"requires arguments");
		if(aflag!='-')
			error(ERROR_exit(1),"cannot be unset");
		base = prefix;
		prefix = 0;
		flag &= ~(NV_IMPORT|NV_ASSIGN);
	}
#endif /* SHOPT_OO */
	flag &= ~(NV_ARRAY|NV_NOSCOPE|NV_VARNAME|NV_IDENT);
	if(argv[1])
	{
		if(flag&NV_REF)
		{
			flag &= ~NV_REF;
			ref=1;
			if(aflag!='-')
				nvflags |= NV_REF;
		}
		while(name = *++argv)
		{
			unsigned newflag;
			Namval_t *np;
			unsigned curflag;
			if(troot == sh.fun_tree)
			{
				/*
				 *functions can be exported or
				 * traced but not set
				 */
				if(flag&NV_LTOU)
				{
					/* Function names cannot be special builtin */
					if((np=nv_search(name,sh.bltin_tree,0)) && nv_isattr(np,BLT_SPC))
						error(ERROR_exit(1),e_badfun,name);
					np = nv_open(name,sh.fun_tree,NV_ARRAY|NV_IDENT|NV_NOSCOPE);
				}
				else
					np = nv_search(name,sh.fun_tree,HASH_NOSCOPE);
				if(np && ((flag&NV_LTOU) || !nv_isnull(np) || nv_isattr(np,NV_LTOU)))
				{
					if(flag==0)
					{
						print_namval(sfstdout,np,0);
						continue;
					}
					if(sh.subshell)
						sh_subfork();
					if(aflag=='-')
						nv_onattr(np,flag|NV_FUNCTION);
					else if(aflag=='+')
						nv_offattr(np,flag);
				}
				else
					r++;
				continue;
			}
			np = nv_open(name,troot,nvflags);
			/* tracked alias */
			if(troot==sh.track_tree && aflag=='-')
			{
				nv_onattr(np,NV_NOALIAS);
				path_alias(np,path_absolute(nv_name(np),NIL(char*)));
				continue;
			}
			if(flag==NV_ASSIGN && !ref && aflag!='-' && !strchr(name,'='))
			{
				if(troot!=sh.var_tree && (nv_isnull(np) || !print_namval(sfstdout,np,0)))
				{
					sfprintf(sfstderr,e_noalias,name);
					r++;
				}
				continue;
			}
			if(troot==sh.var_tree && (nvflags&NV_ARRAY))
				nv_setarray(np,nv_associative);
#ifdef SHOPT_OO
			if(base)
			{
				Namval_t *nq, *nr;
				nv_offattr(np,NV_IMPORT);
				if(!(nq=nv_search(base,troot,0)))
					error(ERROR_exit(1),e_badbase,base);
				/* check for loop */
				for(nr=nq; nr; nr = nv_class(nr))
				{
					if(nr==np)
						error(ERROR_exit(1),e_loop,base);
				}
				np->nvenv = (char*)nq;
				if(nq->nvfun && (nq->nvfun)->disc->create)
					(*(nq->nvfun)->disc->create)(np,0,nq->nvfun);
			}
#endif /* SHOPT_OO */
			curflag = np->nvflag;
			if (aflag == '-')
			{
				if((flag&NV_EXPORT) && strchr(nv_name(np),'.'))
					error(ERROR_exit(1),e_badexport,nv_name(np));
#ifdef SHOPT_BSH
				if(flag&NV_EXPORT)
					nv_offattr(np,NV_IMPORT);
#endif /* SHOPT_BSH */
				newflag = curflag;
				if(flag&~NV_NOCHANGE)
					newflag &= NV_NOCHANGE;
				newflag |= flag;
				if (flag & (NV_LJUST|NV_RJUST))
				{
					if (flag & NV_LJUST)
						newflag &= ~NV_RJUST;
					else
						newflag &= ~NV_LJUST;
				}
				if (flag & NV_UTOL)
					newflag &= ~NV_LTOU;
				else if (flag & NV_LTOU)
					newflag &= ~NV_UTOL;
			}
			else
			{
				if((flag&NV_RDONLY) && (curflag&NV_RDONLY))
					error(ERROR_exit(1),e_readonly,nv_name(np));
				newflag = curflag & ~flag;
			}
			if (aflag && (argnum>0 || (curflag!=newflag)))
			{
				if(sh.subshell)
					sh_assignok(np,1);
				if(troot!=sh.var_tree)
					nv_setattr(np,newflag);
				else
					nv_newattr (np, newflag,argnum);
			}
			/* set or unset references */
			if(ref)
			{
				if(aflag=='-')
					nv_setref(np);
				else
					unref(np);
			}
			nv_close(np);
		}
	}
	else
	{
		if(aflag)
		{
			if(troot==sh.fun_tree)
			{
				flag |= NV_FUNCTION;
				prefix = 0;
			}
			else if(troot==sh.var_tree)
				flag |= (nvflags&NV_ARRAY);
			print_scan(sfstdout,flag,troot,aflag=='+');
		}
		else if(troot==sh.alias_tree)
			print_scan(sfstdout,0,troot,0);
		else
			print_all(sfstdout,troot);
	}
	return(r);
}

typedef int (*Fptr_t) __PROTO__((int, char*[], __V_*));

#define GROWLIB	4
static __V_ **liblist;

/*
 * This allows external routines to load from the same library */
__V_ **sh_getliblist __PARAM__((void), ()){
	return(liblist);
}

/*
 * add change or list built-ins
 * adding builtins requires dlopen() interface
 */
int	b_builtin __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	char *arg=0, *name;
	int n, r=0, flag=0;
	Namval_t *np;
	int dlete=0;
	static int maxlib, nlib;
	Fptr_t addr;
	__V_ *library=0;
	char *errmsg;
	NOT_USED(argc);
	NOT_USED(extra);
	while (n = optget(argv,sh_optbuiltin)) switch (n)
	{
	    case 's':
		flag = BLT_SPC;
		break;
	    case 'd':
		dlete=1;
		break;
	    case 'f':
#ifdef SHOPT_DYNAMIC
		arg = opt_arg;
#else
		error(2, "adding built-ins not supported");
		error_info.errors++;
#endif /* SHOPT_DYNAMIC */
		break;
	    case ':':
		error(2, opt_arg);
		break;
	    case '?':
		error(ERROR_usage(2), opt_arg);
		break;
	}
	argv += opt_index;
	if(error_info.errors)
		error(ERROR_usage(2),optusage(NIL(char*)));
	if(arg || *argv)
	{
		if(sh_isoption(SH_RESTRICTED))
			error(ERROR_exit(1),e_restricted,argv[-opt_index]);
		if(sh.subshell)
			sh_subfork();
	}
	if(arg)
	{
		if(!(library = dlopen(arg,DL_MODE)))
		{
			error(ERROR_exit(0),"%s: %s",arg,dlerror());
			return(1);
		}
		/* 
		 * see if library is already on search list
		 * if it is, move to head of search list
		 */
		for(n=r=0; n < nlib; n++)
		{
			if(r)
				liblist[n-1] = liblist[n];
			else if(liblist[n]==library)
				r++;
		}
		if(r)
			nlib--;
		if(nlib >= maxlib)
		{
			/* add library to search list */
			maxlib += GROWLIB;
			if(nlib>0)
				liblist = (__V_**)realloc((__V_*)liblist,(maxlib+1)*sizeof(__V_**));
			else
				liblist = (__V_**)malloc((maxlib+1)*sizeof(__V_**));
		}
		liblist[nlib++] = library;
		liblist[nlib] = 0;
	}
	else if(*argv==0 && !dlete)
	{
		print_scan(sfstdout, flag, sh.bltin_tree, 1);
		return(0);
	}
	r = 0;
	flag = staktell();
	while(arg = *argv)
	{
		name = path_basename(arg);
		stakputs("b_");
		stakputs(name);
		errmsg = 0;
		addr = 0;
		for(n=(nlib?nlib:dlete); --n>=0;)
		{
			/* (char*) added for some sgi-mips compilers */ 
			if(dlete || (addr = (Fptr_t)dlsym(liblist[n],stakptr(flag))))
			{
				if(sh_addbuiltin(arg, addr,0) < 0)
					errmsg = "restricted name";
				else
					errmsg = 0;
				break;
			}
		}
		if(!dlete && !addr)
		{
			if(np=nv_search(name,sh.bltin_tree,0))
			{
				if(sh_addbuiltin(arg, np->nvalue.bfp,0) < 0)
					errmsg = "restricted name";
			}
			else
				errmsg = "not found";
		}
		if(errmsg)
		{
			error(ERROR_exit(0),"%s: %s",*argv,errmsg);
			r = 1;
		}
		stakseek(flag);
		argv++;
	}
	return(r);
}

int    b_set __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	NOT_USED(extra);
	prefix=0;
	if(argv[1])
	{
		if(sh_argopts(argc,argv) < 0)
			return(2);
		sh_offstate(SH_VERBOSE|SH_MONITOR);
		sh_onstate(sh_isoption(SH_VERBOSE|SH_MONITOR));
	}
	else
		/*scan name chain and print*/
		print_scan(sfstdout,0,sh.var_tree,0);
	return(0);
}

/*
 * The removing of Shell variable names, aliases, and functions
 * is performed here.
 * Unset functions with unset -f
 * Non-existent items being deleted give non-zero exit status
 */

int    b_unalias __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	NOT_USED(extra);
	return(b_unall(argc,argv,sh.alias_tree));
}

int    b_unset __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	NOT_USED(extra);
	return(b_unall(argc,argv,sh.var_tree));
}

static int b_unall __PARAM__((int argc, char **argv, Hashtab_t *troot), (argc, argv, troot)) __OTORP__(int argc; char **argv; Hashtab_t *troot;){
	Namval_t *np;
	struct slnod *slp;
	const char *name;
	int r;
	int nflag = 0;
	int all=0;
	NOT_USED(argc);
	if(troot!=sh.var_tree && sh.subshell)
		sh_subfork();
	if(troot==sh.alias_tree)
		name = sh_optunalias;
	else
		name = sh_optunset;
	while(r = optget(argv,name)) switch(r)
	{
		case 'f':
			troot = sh.fun_tree;
			break;
		case 'a':
			all=1;
			break;
		case 'n':
			nflag = NV_NOREF;
		case 'v':
			troot = sh.var_tree;
			break;
		case ':':
			error(2, opt_arg);
			break;
		case '?':
			error(ERROR_usage(0), opt_arg);
			return(2);
	}
	argv += opt_index;
	if(error_info.errors || (*argv==0 &&!all))
		error(ERROR_usage(2),optusage(NIL(char*)));
	r = 0;
	if(troot==sh.var_tree)
		nflag |= NV_VARNAME;
	if(all)
	{
		hashfree(troot);
		sh.alias_tree = hashalloc(sh.var_tree,HASH_set,HASH_ALLOCATE,0);
	}
	else while(name = *argv++)
	{
		if(np=nv_open(name,troot,NV_NOADD|nflag))
		{
			if(troot!=sh.var_tree)
			{
				if(is_abuiltin(np))
				{
					r = 1;
					continue;
				}
				else if(slp=(struct slnod*)(np->nvenv))
				{
					/* free function definition */
					char *cp= strrchr(name,'.');
					if(cp)
					{
						Namval_t *npv;
						*cp = 0;
						npv = nv_open(name,sh.var_tree,NV_ARRAY|NV_VARNAME|NV_NOADD);
						*cp++ = '.';
						if(npv)
							nv_setdisc(npv,cp,NIL(Namval_t*),(Namfun_t*)npv);
					}
					stakdelete(slp->slptr);
					np->nvenv = 0;
					hashlook(troot,(char*)np,HASH_DELETE|HASH_BUCKET,(char*)0);
					continue;
				}
			}

			if(sh.subshell)
				np=sh_assignok(np,0);
			nv_unset(np);
			nv_close(np);
		}
		else
			r = 1;
	}
	return(r);
}



/*
 * print out the name and value of a name-value pair <np>
 */

static int print_namval __PARAM__((Sfio_t *file,Namval_t *np,int flag), (file, np, flag)) __OTORP__(Sfio_t *file;Namval_t *np;int flag;){
	char *cp;
	sh_sigcheck();
	if(flag)
		flag = '\n';
	if(nv_isattr(np,NV_NOPRINT)==NV_NOPRINT)
	{
		if(is_abuiltin(np))
			sfputr(file,np->nvenv?np->nvenv:nv_name(np),'\n');
		return(0);
	}
	if(prefix)
		sfputr(file,prefix,' ');
	if(is_afunction(np))
	{
		if(!flag && !np->nvalue.ip)
			sfputr(file,"typeset -fu",' ');
		else if(!flag && !nv_isattr(np,NV_FPOSIX))
			sfputr(file,"function",' ');
		if(!np->nvalue.ip || np->nvalue.rp->hoffset<0)
			flag = '\n';
		sfputr(file,nv_name(np),flag?flag:-1);
		if(!flag)
		{
			sfputr(file,nv_isattr(np,NV_FPOSIX)?"()\n{":"\n{",'\n');
			hist_list(sh.hist_ptr,file,np->nvalue.rp->hoffset,0,"\n");
		}
		return(nv_size(np)+1);
	}
	if(cp=nv_getval(np))
	{
		Namarr_t *ap;
		sfputr(file,sh_fmtq(nv_name(np)),-1);
		if(!flag)
		{
			flag = '=';
		        if(ap = nv_arrayptr(np))
				sfprintf(file,"[%s]", sh_fmtq(nv_getsub(np)));
		}
		sfputc(file,flag);
		if(flag != '\n')
			sfputr(file,sh_fmtq(cp),'\n');
		return(1);
	}
	else if(scanmask && scanroot==sh.var_tree)
		sfputr(file,nv_name(np),'\n');
	return(0);
}

/*
 * print attributes at all nodes
 */

static void	print_all __PARAM__((Sfio_t *file,Hashtab_t *root), (file, root)) __OTORP__(Sfio_t *file;Hashtab_t *root;){
	outfile = file;
	nv_scan(root, print_attribute, 0, 0);
}

#include	<fcin.h>
#include	"argnod.h"

/*
 * format initialization list given a list of assignments <argp>
 */
static void genvalue __PARAM__((struct argnod *argp, const char *prefix, int n, int indent), (argp, prefix, n, indent)) __OTORP__(struct argnod *argp; const char *prefix; int n; int indent;){
	struct argnod *ap;
	char *cp,*nextcp;
	int m,isarray;
	Namval_t *np;
	if(n==0)
		m = strlen(prefix);
	else
		m = strchr(prefix,'.')-prefix;
	m++;
	if(outfile)
	{
		sfwrite(outfile,"(\n",2);
		indent++;
	}
	for(ap=argp; ap; ap=ap->argchn.ap)
	{
		if(ap->argflag==ARG_MAC)
			continue;
		cp = ap->argval+n;
		if(n==0 && cp[m-1]!='.')
		{
			ap->argflag = ARG_MAC;
			continue;
		}
		if(n && cp[n-1]==0)
			continue;
		if(n==0 || strncmp(ap->argval,prefix-n,m+n)==0)
		{
			cp +=m;
			if(nextcp=strchr(cp,'.'))
			{
				if(outfile)
				{
					sfnputc(outfile,'\t',indent);
					sfwrite(outfile,cp,nextcp-cp);
					sfputc(outfile,'=');
				}
				genvalue(argp,cp,n+m ,indent);
				if(outfile)
					sfputc(outfile,'\n');
				continue;
			}
			ap->argflag = ARG_MAC;
			if(!(np=nv_search(ap->argval,sh.var_tree,0)))
				continue;
			if(np->nvfun && np->nvfun->disc== &treedisc)
				continue;
			isarray=0;
			if(nv_isattr(np,NV_ARRAY))
			{
				nv_putsub(np,NIL(char*),ARRAY_SCAN);
				isarray=1;
			}
			if(!outfile)
			{
				nv_close(np);
				continue;
			}
			sfnputc(outfile,'\t',indent);
			if(nv_isattr(np,~NV_DEFAULT))
				print_attribute(np);
			sfputr(outfile,cp,'=');
			if(isarray)
			{
				sfwrite(outfile,"(\n",2);
				sfnputc(outfile,'\t',++indent);
			}
			while(1)
			{
				if(isarray)
				{
					sfprintf(outfile,"[%s]",sh_fmtq(nv_getsub(np)));
					sfputc(outfile,'=');
				}
				sfputr(outfile,sh_fmtq(nv_getval(np)),'\n');
				if(!ap || !nv_nextsub(np))
					break;
				sfnputc(outfile,'\t',indent);
			}
			if(isarray)
			{
				sfnputc(outfile,'\t',--indent);
				sfwrite(outfile,")\n",2);
			}
		}
	}
	if(outfile)
	{
		if(indent > 1)
			sfnputc(outfile,'\t',indent-1);
		sfputc(outfile,')');
	}
}

/*
 * walk the virtual tree and print or delete name-value pairs
 */
static char *walk_tree __PARAM__((Namval_t *np, int dlete), (np, dlete)) __OTORP__(Namval_t *np; int dlete;){
	static Sfio_t *out;
	int n;
	Fcin_t save;
	int savtop = staktell();
	char *savptr = stakfreeze(0);
	struct argnod *ap;
	struct argnod *arglist=0;
	char *name = nv_name(np);
	stakseek(ARGVAL);
	stakputs("\"${!");
	stakputs(name);
	stakputs("@}\"");
	ap = (struct argnod*)stakfreeze(1);
	ap->argflag = ARG_MAC;
	fcsave(&save);
	n = sh_macexpand(ap,&arglist);
	fcrestore(&save);
	ap = arglist;
	if(dlete)
		outfile = 0;
	else if(!(outfile=out))
		outfile = out =  sfnew((Sfio_t*)0,(char*)0,-1,-1,SF_WRITE|SF_STRING);
	else
		sfseek(outfile,0L,SEEK_SET);
	prefix = "typeset";
	aflag = '=';
	genvalue(ap,name,0,0);
	stakset(savptr,savtop);
	if(!outfile)
		return((char*)0);
	sfputc(out,0);
	return((char*)out->data);
}

/*
 * get discipline for compound initializations
 */
static char *get_tree __PARAM__((Namval_t *np, Namfun_t *fp), (np, fp)) __OTORP__(Namval_t *np; Namfun_t *fp;){
	NOT_USED(fp);
	return(walk_tree(np,0));
}

/*
 * put discipline for compound initializations
 */
static void put_tree __PARAM__((Namval_t *np, const char *val, int flags,Namfun_t *fp), (np, val, flags, fp)) __OTORP__(Namval_t *np; const char *val; int flags;Namfun_t *fp;){
	walk_tree(np,1);
	if(fp = nv_stack(np,NIL(Namfun_t*)))
	{
		free((__V_*)fp);
		if(np->nvalue.cp && !nv_isattr(np,NV_NOFREE))
			free((__V_*)np->nvalue.cp);
	}
	if(val)
		nv_putval(np,val,flags);
}

/*
 * Insert discipline to cause $x to print current tree
 */
void nv_setvtree __PARAM__((Namval_t *np), (np)) __OTORP__(Namval_t *np;){
	Namfun_t *nfp = newof(NIL(__V_*),Namfun_t,1,0);
	nfp->disc = &treedisc;
	nv_stack(np, nfp);
}

/*
 * print the attributes of name value pair give by <np>
 */
static void	print_attribute __PARAM__((Namval_t *np), (np)) __OTORP__(Namval_t *np;){
	const Shtable_t *tp;
	char *cp;
	unsigned val;
	unsigned mask;
#ifdef SHOPT_OO
	Namval_t *nq;
	char *cclass=0;
#endif /* SHOPT_OO */
	if (nv_isattr(np,~NV_DEFAULT))
	{
		if(prefix)
			sfputr(outfile,prefix,' ');
		for(tp = shtab_attributes; *tp->sh_name;tp++)
		{
			val = tp->sh_number;
			mask = val;
			if(val&NV_INTEGER)
				mask |= NV_DOUBLE;
			if(nv_isattr(np,mask)==val)
			{
				if(val==NV_ARRAY)
				{
					Namarr_t *ap = nv_arrayptr(np);
					if(array_assoc(ap))
						cp = "associative";
					else
						cp = "indexed";
					if(!prefix)
						sfputr(outfile,cp,' ');
					else if(*cp=='i')
						continue;
				}
				if(prefix)
				{
					if(*tp->sh_name=='-')
						sfprintf(outfile,"%.2s ",tp->sh_name);
				}
				else
					sfputr(outfile,tp->sh_name+2,' ');
		                if ((val&(NV_LJUST|NV_RJUST|NV_ZFILL)) && !(val&NV_INTEGER))
					sfprintf(outfile,"%d ",nv_size(np));
			}
		        if(val == NV_INTEGER && nv_isattr(np,NV_INTEGER))
			{
				if(nv_size(np) != 10)
				{
					if(nv_isattr(np, NV_DOUBLE))
						cp = "precision";
					else
						cp = "base";
					if(!prefix)
						sfputr(outfile,cp,' ');
					sfprintf(outfile,"%d ",nv_size(np));
				}
				break;
			}
		}
#ifdef SHOPT_OO
		if(nq=nv_class(np))
		{
			if(prefix && *prefix=='t')
				cclass = "-C";
			else if(!prefix)
				cclass = "class";
			if(cclass)
				sfprintf(outfile,"%s %s ",cclass,nv_name(nq));
		
		}
#endif /* SHOPT_OO */
		if(aflag)
			return;
		sfputr(outfile,nv_name(np),'\n');
	}
}

/*
 * print the nodes in tree <root> which have attributes <flag> set
 * of <option> is non-zero, no subscript or value is printed.
 */

static void print_scan __PARAM__((Sfio_t *file, int flag, Hashtab_t *root, int option), (file, flag, root, option)) __OTORP__(Sfio_t *file; int flag; Hashtab_t *root; int option;){
	char **argv;
	Namval_t *np;
	int namec;
	Namval_t *onp = 0;
	flag &= ~NV_ASSIGN;
	scanmask = flag;
	scanroot = root;
	outfile = file;
	if(flag&NV_INTEGER)
		scanmask |= (NV_DOUBLE|NV_EXPNOTE);
	namec = nv_scan(root,nullscan,scanmask,flag);
	argv = argnam  = (char**)stakalloc((namec+1)*sizeof(char*));
	namec = nv_scan(root, pushname, scanmask, flag);
	strsort(argv,namec,strcoll);
	while(namec--)
	{
		if((np=nv_search(*argv++,root,0)) && np!=onp && (!nv_isnull(np) || np->nvfun || nv_isattr(np,~NV_NOFREE)))
		{
			onp = np;
			if((flag&NV_ARRAY) && nv_aindex(np)>=0)
				continue;
			if(!flag && nv_isattr(np,NV_ARRAY))
			{
				if(array_elem(nv_arrayptr(np))==0)
					continue;
				nv_putsub(np,NIL(char*),ARRAY_SCAN);
				do
				{
					print_namval(file,np,option);
				}
				while(!option && nv_nextsub(np));
			}
			else
				print_namval(file,np,option);
		}
	}
}

/*
 * add the name of the node to the argument list argnam
 */

static void pushname __PARAM__((Namval_t *np), (np)) __OTORP__(Namval_t *np;){
	*argnam++ = nv_name(np);
}

/*
 * The inverse of creating a reference node
 */
static void unref __PARAM__((Namval_t *np), (np)) __OTORP__(Namval_t *np;){
	if(!nv_isattr(np,NV_REF))
		return;
	nv_offattr(np,NV_NOFREE|NV_REF);
	np->nvalue.cp = strdup(nv_name(np->nvalue.np));
	return;
}

