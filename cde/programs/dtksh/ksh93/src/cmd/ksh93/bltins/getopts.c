/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these libraries and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* $XConsortium: getopts.c /main/3 1995/11/01 16:28:23 rswiston $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*        THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF        *
*                    AT&T BELL LABORATORIES                    *
*         AND IS NOT TO BE DISCLOSED OR USED EXCEPT IN         *
*            ACCORDANCE WITH APPLICABLE AGREEMENTS             *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*              Unpublished & Not for Publication               *
*                     All Rights Reserved                      *
*                                                              *
*       The copyright notice above does not evidence any       *
*      actual or intended publication of such source code      *
*                                                              *
*               This software was created by the               *
*           Advanced Software Technology Department            *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                    {research,attmail}!dgk                    *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include	"defs.h"
#include	"variables.h"
#include	<error.h>
#include	<nval.h>
#include	"builtins.h"

int	b_getopts __PARAM__((int argc,char *argv[],__V_ *extra), (argc, argv, extra)) __OTORP__(int argc;char *argv[];__V_ *extra;){
	char *options=error_info.context->id;
	Namval_t *np;
	int flag, mode, r=0;
	static char value[2], key[2];
	NOT_USED(extra);
	while((flag = optget(argv,sh_optgetopts))) switch(flag)
	{
	    case 'a':
		options = opt_arg;
		break;
	    case ':':
		error(2, opt_arg);
		break;
	    case '?':
		error(ERROR_usage(2), opt_arg);
		break;
	}
	argv += opt_index;
	argc -= opt_index;
	if(error_info.errors || argc<2)
		error(ERROR_usage(2),optusage((char*)0));
	error_info.context->flags |= ERROR_SILENT;
	error_info.id = options;
	options = argv[0];
	np = nv_open(argv[1],sh.var_tree,NV_NOASSIGN|NV_VARNAME);
	if(argc>2)
	{
		argv +=1;
		argc -=1;
	}
	else
	{
		argv = sh.st.dolv;
		argc = sh.st.dolc;
	}
	opt_index = sh.st.optindex;
	opt_char = sh.st.optchar;
	if(mode= (*options==':'))
		options++;
	switch(opt_index<=argc?(opt_num= LONG_MIN,flag=optget(argv,options)):0)
	{
	    case '?':
		error(ERROR_usage(0),opt_arg);
		r = 2;
		*(options = value) = flag;
		break;
	    case ':':
		key[0] = opt_option[1];
		if(strmatch(opt_arg,"*unknown*"))
			flag = '?';
		if(mode)
			opt_arg = key;
		else
		{
			error(2, opt_arg);
			opt_arg = 0;
			flag = '?';
		}
		*(options = value) = flag;
		sh.st.opterror = 1;
		break;
	    case 0:
		if(sh.st.opterror)
		{
			char *com[2];
			com[0] = "-?";
			com[1] = 0;
			flag = opt_index;
			opt_index = 0;
			optget(com,options);
			opt_index = flag;
			if(!mode && strchr(options,' '))
				error(ERROR_usage(0),optusage((char*)0));
		}
		opt_arg = 0;
		options = value;
		*options = '?';
		r=1;
		opt_char = 0;
		break;
	    default:
		options = opt_option + (*opt_option!='+');
	}
	error_info.context->flags &= ~ERROR_SILENT;
	sh.st.optindex = opt_index;
	sh.st.optchar = opt_char;
	nv_putval(np, options, 0);
	nv_close(np);
	np = nv_search((char*)OPTARGNOD,sh.var_tree,NV_ADD|HASH_BUCKET|HASH_NOSCOPE);
	if(opt_num != LONG_MIN)
	{
		double d = opt_num;
		nv_putval(np, (char*)&d, NV_INTEGER|NV_RDONLY);
	}
	else
		nv_putval(np, opt_arg, NV_RDONLY);
	return(r);
}

